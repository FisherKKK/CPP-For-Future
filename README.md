# CPP-For-Future

> 这是一个面向未来的C++, 从C语言角度看C++

[toc]

## 基本概念



### 变量和基本数据类型

#### 内置基本类型

* 算术类型

  也就是基本的C语言数据类型以及后来的`bool`类型, 为了使C++具有更好的平台兼容性, 我们可以使用固定尺寸的数据类型, 例如: `int_32`, `int_64`等等

* 空类型

  `void`类型

* 有符号和无符号类型



> 基本上和C语言的类型没有太大差异

#### 类型转换

一般来说对于循环中的计数变量, 请不要将之定义为**无符号**类型.

##### 字面值常量

* 整型和浮点型字面值

  还是和C语言的一致

* 字符和字符串面值

* 转义序列

* 指定字面值类型

  1. `L`前缀指定`wchart_t`类型
  2. `u8`前缀指定字符串面值为`utf-8`格式
  3. `U`后缀指定无符号类型
  4. `u`前缀指定`unicode 16`字符, `U`前缀指定`unicode_32`字符
  5. `L`指定`long`类型



### 变量定义

变量的基本类型首先是**类型说明符**, 随后紧跟一个或者多个变量名组成的列表, 其中变量名以逗号分隔, 最后以分号结束

> 什么是对象?
>
> 对象是具有某种数据类型的内存空间

####  初始值

当对象在创建时获得了特定值, 称之为对象被**初始化**了

> 初始化不是赋值, 初始化的含义是创建变量时赋予其一个初始值, 而赋值的含义是把对象的当前值擦除, 而以一个新值来替代

#### 列表初始化

* 采用C语言`=`的方式进行初始化
* 采用花括号`{}`方式进行初始化, 这种初始化方式称为**列表初始化**, 这种初始化可以避免变量**窄缩**

####  默认初始化

如果定义变量时没有指定初始化值, 则变量将会**默认初始化**, 此时变量被赋予默认值, 这个值是什么由变量类型和定义位置决定.

* 如果内置类型未被显式初始化, 它的值由定义位置决定. **定义于任何函数体之外的变量被初始化为0**. 定义在函数体内部的内置类型变量将**不被初始化**, 也就是其中的值为**垃圾值**.
* 每个外部类自行决定初始化对象的方式, 绝大多数类都支持无须显式初始化而定义对象, 这样的类提供了合适的默认值., 例如`string`
* 还有一些类要求每个对象都显示初始化



#### 变量声明和定义关系

为了允许把程序拆分成多个逻辑部分来编写, `C++`支持**分离式编译**机制, 即将程序分割为若干文件, 每个文件可以独立编译; 为了将程序分为多个文件, 则需要在文件间共享代码的方法.

`C++`将声明和定义区分开. **声明**使得名字为程序所知, 一个文件如果想要使用别处定义的名字则必须包含对那个名字的声明. 而**定义**负责创建和名字关联的实体. 声明规定了变量的类型和名字, 而定义还申请存储空间, 也可能为变量赋值一个初始化值.

*  如果想声明一个变量而非定义它, 就在变量名前添加关键字`extern`, 任何包含了初始化的声明都会导致内存分配, 从而使声明变成定义.**尤其要注意一点, 变量只能定义一次, 但是可以多次声明**

> 静态类型
>
> `C++`是一种**静态类型**语言, 也就是在编译阶段检查类型. 其中, 检查类型的过程中称为**类型检查**




### 标识符

变量名规范继承了`C`语言的传统



### 作用域

同一个名字在不同的作用域可能指向不同的实体. 名字有效区域始于名字的声明语句, 以声明语句所在的作用域末端为结束. 而作用域以花括号`{}`进行定义

* 名字定义于所有的花括号之外拥有全局作用域, 从声明处开始具有域的范围
* 在同一个作用域存在多个同名变量的话采用**局部优先**原则



### 复合类型

基本的复合类型: **指针**和**引用**



#### 引用

一般的引用为**左值引用**, 引用相当于为**对象**另外起了一个名字, 采用`T &`来表示这是一个引用类型, 引用**必须在定义的时候初始化**, 定义引用时, 程序把引用和初始值**绑定binding**到一块, 也就是**别名**.

如果我们采用的是直接赋值, 相当于是在开辟了一个存储空间, 再将值**copy**到新内存当中.

> 由于引用本身不是一种类型, 只是一个别名, 因此不允许定义一个引用的引用(因为标准说不行)



特殊情况:

* 左值引用必须要对象进行绑定, 而不能和**字面值和表达式**绑定
* 左值引用必须要类型匹配



#### 指针

**指针**指向另外一种类型的的符合类型, 我想跳过这一节, 因为相比于`C`, 指针在`C++`没有太多扩展.

* 空指针不指向任何类型, 在试图对一个指针进行操作的时候首先要检查它是否为空, 采用`nullptr`来表示空指针. `nullptr`可以被转换为任意其它类型的空指针.
* `void*`指针, 它可以指向任何数据类型, 但是无法取对象, 因此取对象的时候我们需要进行强制转换

一般遇到类型复杂的时候, **我们采用从右向左读的方式进行类型解析**



### `const`限定符

`const`对象被创建之后它的值就不能被改变了, 所以它必须进行初始化

#### 默认情况下`const`对象仅在文件内有效

如果多个文件中都想使用`const`定义的变量, 我们必须在**每个使用到它的文件中都单独的进行定义**, 因此默认情况下**`const`被设定为仅在当前文件内有效**, 如果我们想要在多个文件中进行共享那么**不管定义还是声明我们都需要在它之前添加`extern`**

```c++
// file1.cpp中定义一个const常量
extern const int bufSize = fcn();

// file2.cpp中我们可以进行引用
extern const int bufSize;
```

#### `const`引用

可以把引用绑定到`const`对象上, 我们称之为**对`const`的引用**, 和普通引用所不同的是, 对常量的引用不能改变它所绑定的对象, 也就是这种引用表名**它所引用的对象都是常量, 包括基本类型**

#### 初始化和对`const`的引用

一般来说引用的类型必须要和所引用对象的类型保持一致, 但是存在两个例外:

1. 初始化常量引用的时候允许用任意表达式作为初始值, 只要该表达式的结果能转换成引用的类型即可. 尤其, 允许一个常量引用绑定非常量的对象, 字面值甚至一般表达式

   可是该如何理解这种行为呢? 实际上编译器做了优化

   ```c++
   double dval = 3.14;
   const int & ri = dval;
   // 上面是一个很正确的C++引用的赋值
   
   // 实际上编译器做了如下的优化
   const int temp = dval;
   const int &ri = temp;
   // 也就是在引用过程中产生了一个临时的整型常量, 也就是所说的临时量
   ```

   **临时量**就是引用表达式, 和类型不匹配时编译器的解决方法

2. 对`const`的引用可能并非引用一个`const`对象



#### 指针和`const`

这一点和`C`语言并没有什么不同, `const`在前表示指向的值无法改变, `const`在后表示指针无法被改变;

`const`指针意味着指向常量的指针, 因此可以用指向**常量**



### 顶层`const`

**顶层`const`**表示指针本身是一个常量, **底层`const`**表示指针所指的对象为一个常量, **因此, 我们可以通过判断变量本身是否可变来表示顶层和底层**(自己最大)



### `constexpr`和常量表达式

**常量表达式**是指值不会改变并且在编译过程就能得到计算结果的表达式. 显然字面值属于常量表达式. 采用常量表达式初始化的`const`对象也是常量表达式.

一个对象是不是常量表达式由它的数据类型和初始值共同决定, 例如:

```c++
const int max_files = 20; // max_file常量表达式
const int limit = max_file + 1; // limit是常量表达式
int staff_size = 27; // 不是常量表达式
```

#### `constexpr`变量

允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式. **声明为`constexpr`的变量一定是一个常量, 而且必须用常量表达式初始化**:

```c++
constexpr int mf = 20;
constexpr int limit = mf + 1;
constexpr int sz = size(); // 只有当size是一个constexpr函数时才是一条正确的声明语句
```

新标准允许定义一种特殊`constexpr`函数, 这种函数简单到足以在编译的时候就计算结果, 这样就能用`constexpr`函数去初始化`constexpr`变量了.

> 一般来说, **如果你认为变量是一个常量表达式, 那么就把它声明为`constexpr`类型**



### 字面值类型

常量表达式的值在编译时就得到计算, 因此对声明`constexpr`时用到的类型必须有所限制, 一般把这些类型称为**字面值类型**. 到目前为止接触过的数据类型中:

* 算术类型
* 引用
* 指针

都属于字面值类型. **尽管指针和引用都能定义成`constexpr`**, 但`constexpr`指针的初始值必须是`nullptr`或者`0`, 或者是存储于某个固定地址中对象.  函数体内定义的变量一般来说并非存放在**固定地址中**, 因此`constexpr`指针不能指向这样的变量. 定义于所有函数体之外的对象其地址**固定不变**. 因此`constexpr`能绑定到这样的变量上, `constexpr`指针也能指向这样的变量.



#### 指针和`constexpr`

在`constexpr`声明中如果定义了一个指针, 限定符`constexpr`仅对指针有效, 与指针所指的对象无关

```c++
constexpr int *q = nullptr; // q是一个指向整数的常量指针
// q是一个常量指针, constexpr把它所定义的对象置为了顶层const
```



### 处理类型

#### 类型别名

**类型别名**是否中类型的同义词, 可以让复杂类型名字变得简单明了, 易于理解和使用, 有两种方法可用于定义类型别名:

* `typedef`

  ```c++
  typedef double wages;
  typedef wages base, *p;
  ```

  `typedef`作为声明语句前缀之后, 变量名就代表了类型别名, 这里和`C`的用法一致.

* `using`

  新标准规定了**别名声明**来定义类型的别名

  ```c++
  using SI = Sales_item; // SI是Sales_item的同义词
  ```

  这种方法用关键字`using`作为别名声明的开始, 其后紧跟别名和等号, 其作用是把等号左侧的名字规定成等号右侧类型的别名.

#### 指针, 常量和类型别名

```c++
typedef char *pstring;
const pstring cstr = 0; // cstr是指向char的常量指针
const pstring *ps; // ps是一个指针, 它的对象是指向char的常量指针
```

可以这样解释: `pstring`是一个指向`char`的指针, 那么`const pstring cstr = 0`就是一个常量指针指向`char`



### `auto`类型说明符

可以让编译器代替我们去分析表达式所属的类型, 显然`auto`定义的变量必须要有初始值.

#### 符合类型, 常量和`auto`

* 遇到引用时, 以引用中值的类型作为`auto`类型

* `auto`会忽略掉**顶层`const`**, 同时**底层`const`**会被保留下来, 比如**指向常量的指针**

  ```c++
  const int ci = i, &cr = ci;
  auto b = ci; // b是一次整数
  auto c = cr; // c是一个整数
  auto d = &i; // d是一个整型指针
  auto e = &ci; // e是一个指向整型常量的指针(对常量对象取地址是一种底层const)
  ```

* 如果希望`auto`推断出顶层`const`, 需要指出

  ```c++
  const auto f = ci; // ci为int, f是const int
  ```

* 还可以将引用类型设为`auto`

  ```c++
  auto &g = ci; // g是一个整型常量引用
  auto &h = 42; 
  const auto &j = 42;
  ```




### `decltype`类型指示符

希望从表达式的类型推断出要定义的变量的类型， 但是不想用该表达式的值初始化变量， 为了满足这一个需求， `decltype`就可以大显身手, 它的作用时选择并返回操作数的数据类型:

```c++
decltype(f()) sum = x; // sum的类型就是函数f返回值类型
```

`decltype`处理顶层`const`和底层`const`的方法和`auto`有所不同, 如果`decltype`使用的表达式是一个变量, 那么`decltype`返回该变量的类型(包括顶层和引用)

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0;
decltype(cj) y = x;
decltype(cj) z; // 错误, 必须要初始化
```

#### `decltype`和引用

如果`decltype`使用的表达式不是一个变量, 则`decltype`返回表达式结果对应的类型, `decltype`的

```c++
int i = 32, *p = &i, &r = i;
decltype(r + 0) b; // 正确, 加法的结果是int, 因此b是一个未初始化的int
decltype(*p) c; // 错误, c是int &, 必须初始化
```

因为`r`是一个引用, 因此`decltype(r)`的结果是一个引用类型, 如果想要变成值类型, 可以将它作为表达式的一部分, 也就是说**如果`decltype`使用的表达式不是一个变量, 则`decltype`**返回表达式结果对应 的类型.

如果表达式的内容是一个解引用的操作, **那么就会产生引用类型, 因为这种类型可以改变原本的值, 所以选的是引用**

`decltype`和`auto`的另一个重要的区别是, `decltype`的结果和表达式形式密切, 如果`decltype`使用一个不加括号的变量, 则得到的就是该变量的类型, 如果变量加上了括号, 编译器就会把它当作一个表达式, 变量是一种可以作为赋值语句的特殊表达式, 所以这样的`decltype`就得到引用:

```c++
// decltype的表达式加上了括号变量, 结果将是引用
decltype((i)) d; // 错误, d是int&, 必须初始化
```

> 切记: `decltype((variable))`永远是引用, 而`decltype(variable)`结果只有当`variable`本身就是引用时才是引用



### 自定义数据结构

#### 类的数据成员

**数据成员**定义了类对象的具体内容, 每个对象都有一份数据成员copy, , 修改一个成员不会影响其余的成员

新标准规定, 可以为数据成员提供一个**类内初始化值**, 创建对象时, 类内初始化值将用于初始化值用于初始化数据成员. 没有初始化的成员将被默认初始化.



### 编写自己的头文件

类一般都不定义在函数体内, 挡在函数体外部定义类的时候, 在各个指定的源文件中可能只有一处该类的定义. 而且, 如果要在不同的文件中使用同一个类, 类的定义就必须保持一致.

头文件通常包含那些只能被定义一次的实体, 如类, `const`和`constexpr`变量



### 预处理器概念

确保头文件多次包含仍能安全工作的常用奇数时**预处理器**, 由`C++`语言从`C`语言继承而来, 一般采用`#ifndef`和`#define`以及`#endif`来防止头文件重复包含



## 字符串, 向量和数组



### 命名空间的`using`声明

我们用到的库函数基本都属于命名空间`std`, 作用域操作符`::`的含义时: 编译器应该从操作符左侧名字所示的作用域中寻找右侧那个名字, 但是**`using`声明**会将之边的简单. 

```c++
using namespace::name; // 可以直接访问命名空间的名字
```



#### 每个名字都需要独立的`using`声明

#### 头文件不应该包含`using`声明

如果头文件里有某个`using`声明, 那么每个使用了该头文件就会有这个声明. 对应某些程序, 可能会产生冲突.



### 标准库类型`string`

#### 常规操作

* 定义和初始化

  ```c++
  string str(10, 'c') // 表示10个c
  ```

* `=`表示拷贝初始化, 把等号右侧的初始值直接拷贝到左边, 实际上是先创建一个临时对象

* 如果不使用等号, 那么执行的时候**直接初始化**. 效率更高

* `getline()`作为`string`的输入流函数, 自动忽略空行, 也就是按行输入, 直到遇到换行符为止, 因此不包含`空行`

* `cin`按单词输入, 会自动忽略空行和空格

* `while(cin >> str)`可以用作不定数目的输入

* `string::size_type`表示长度的尺寸, 这里允许我们使用`auto`进行自动推断

* 处理`string`对象中的字符, 采用头文件中的`cctype`头文件定义标准库函数处理

* 处理每个字符, 采用基于范围的`for`循环

  ```c++
  for (dec: expr)
      statement
  ```

  使用范围`for`循环改变字符串中的字符, 可以把循环变量改变曾引用的格式, 这样就可以改变循环中的值, 转换为大写

### 标准库`vector`

表示对象的集合, 其中所有对象的类型都相同, 索引用于访问对象, 也称为**vector**, `C++`既有类模板, 也有函数模板, `vector`是一个类模板. 编译器根据模板创建类或者函数的过程称为**实例化**                      

#### 基本操作

* 定义和初始化操作

  ```c++
  // 只说明我没有见过的
  vector<T> v1;
  vector<T> v2(v1); // 直接初始化
  vector<T> v3(n, val); // 包含n个val
  vector<T> v4(n); // 包含n各个执行了初始化的对象
  vector<T> v5{a, b, c}; // 显式初始化赋值, 称为列表初始化
  ```

  `C++`提供了多种初始化方式, 第一个是拷贝初始化, 其次还有类内初始化,只能使用拷贝初始胡和花括号的形式, 以及列表初始化

  > 列表初始化会兼容()初始化

* 动态`push_back`效率更高

* 无法采用下标方式添加元素



### 迭代器介绍

迭代器提供了对象的间接访问, 有效的迭代器或者指向或者指向某个元素, 或者指向容器中尾元素的下一个位置, 其它所有情况都属于无效.

#### 使用迭代器

`begin`指向第一个元素的迭代器, `end`负责返回**尾元素的下一个位置**的迭代器, 也就是说该迭代器指示的容器的本不存在的**尾后**

##### 迭代器运算符

采用`==`和`!=`来比较两个合法迭代器相等

| `*iter` 所指元素的引用       |
| ---------------------------- |
| `iter->mem` 解引用并获取成员 |
| `++iter`指向下一个元素       |
| `--iter`指向上一个元素       |
| `==` 和`!=`判断相等          |

#### 迭代器类型

`vector<T>::iterator it`可以读写的迭代器, `vector<T>::const_iterator`只读元素



##### `begin`和`end`

返回类型有对象是否为常量决定, 如果为常量就返回只读, 否则返回普通的, 后来添加的`cbegin`和`cend`一定返回的是`const`类型



> 切记: 但凡是使用了迭代器的循环体, 都不要向迭代器所属的容器添加元素, 因为动态增长会是迭代器失效

##### 迭代器的算术运算

一直支持这种迭代器运算的的序列一般为顺序序列.



### 数组

数组也是存放类型相同的对象的容器, 但是这些对象需要通过位置访问, 数组的大小确定不变, 无法向其中增加元素, 性能比较好

> 数组的维度必须是一个常量表达式, 即`constxpr`类型

**这个部分由于和`C`过于类似, 所以不再细谈**

#### 标准库中的`begin`和`end`

新标准引入了`begin()`和`end()`函数, 一个返回组数的首元素地址, 另一个返回尾后元素地址



### `C`-style字符串

用法和`C`相同, 不再一一进行解释



### 多维数组

实际上是数组的数组, 阅读时由内向外推导





## 表达式

### 基础

#### 基本概念

基本使用和`C++`一样, 整型提升, 运算符结合顺序和结合性都是已经定义好的.

##### 左值和右值

基本概念是左值可以出现在赋值运算的左边, 右值可以出现在赋值运算的右边

**标准理解: 左值是指在内存中存在实际位置的对象, 可以理解成对于这个对象可以进行取地址运算,所有非左值都是右值.**

当一个对象被用作右值的时候, 采用的是对象中的值, 当对象被用作左值的时候, 用的是对象的身份(在内存中的位置), 当对象被用作左值的时候， 用的是对象的身份.

下面是几种常用的左值:

* 赋值运算符需要一个(非常量左值)作为其左侧运算对象, 得到的结果也仍然是一个左值
* **取地址运算符作用于一个左值运算对象, 返回一个指向该运算对象的指针, 指针是一个右值**
* 内置解引用运算符, 下标运算符, 迭代器解引用运算符的求值结果都是左值
* 内置类型和迭代器类型的递增递减运算符都作用域左值对象, 前置版本所得的结果也是左值

尤其使用关键字`decltype`的时候, 如果表达式所求值结果是左值, 那么关键字作用时得到一个引用类型

```c++
int i = 0;
int *p = &i;
decltype(*p) m = i; // 实际上会产生引用类型
decltype(&p) c; // 由于取地址运算符产生右值, 所以c是int**
```

#### 优先级和结合律

基本上和`C`的没有什么大不同, 求值顺序一般是未定义的

#### 求值顺序

`C++11`新标准规定商一律向0取整.



### 赋值运算符

`C++`新标准允许使用花括号括起来的初始化列表作为赋值语句的右侧运算对象, 对于`vector`也照样适用.

##### 赋值运算符的优先级较低

优先级`[] () . ->`是最高优先级, 其次是单目运算符, `++ *`

##### 前置版本的递增运算符效率要更高一点, 并且更符合变成规范

一种很重要的省略, `*p++`, 由于结合性的原因, 实际上等同于`*(p++)`

`++`后置是先运算, 再加; `++`前置是先加, 再运算



### 成员访问运算符

`.`和`->`运算符, 箭头运算符作用一个指针类型的运算对象, 结果是一个左值. 点运算分成两种情况, 如果成员所属的对象是左值, 那么结果是左值; 反之如果成员所属的对象是右值, 那么结果也是右值



### `sizeof`运算符

返回一个类型所占字节数, `sizeof`可以作用无效指针的解引用, 因为它不计算值, 它只进行推断



### 逗号运算符

最后一个表达式作为返回值



### 类型转换

#### 隐式类型转换

和`C`语言基本一致, 因此不再赘述

#### 显式类型转换

##### 命名的强制类型转换

格式如下:

```cpp
cast-name<type>(expression);
```

其中`type`是转换的目标类型而`expression`是要转换的值, 如果`type`是引用类型, 则结果是左值类型. `cast-name`是`static_cast`, `dynamic_cast`和`const_cast`和`reinterpret_cast`中的一种.

* `static_cast`任何具有明确定义的类型转换, 只要不包含底层`const`, 都可以使用`static_cast`, 在把一个较大的算术类型赋值给较小的类型的时候, 非常有用, 此时强制类型转换告诉编译器我不在乎可能会丢失的精度

* `const_cast`只能改变运算对象的底层`const`

  ```c++
  const char *pc;
  char *p = const_cast<char*>(pc); // 将底层const转换为普通
  ```

  我们称之为去掉`const`性质, 一旦我们去掉了`const`性质, 也仅有`const_cast`可以改变常量属性. 常常用于有函数重载的上文文当中.

* `reinterpret_cast`

  通常为运算对象的位模式提供较低层次上的重新解释, 很危险, 一般用在底层的罗基范以上



### 运算符优先级

| ::     |
| ------ |
| .      |
| ->     |
| []     |
| ()     |
| ++     |
| --     |
| typeid |



## 语句

### 简单语句

略

#### 范围`for`语句

```c++
for (decl: exp)
    statement;
```

`exp`必须要实现迭代器



### `try`语句块和异常处理

异常是指存在运行时的反常行为, 处理一行行为时所有系统设计最难的一部分. 异常处理机制为程序中**异常检测**和**异常处理**这两部分的协作提供支持, `C++`处理包括:

* `throw`表达式

  异常检测部分使用`throw`表达式来表示它遇到了无法处理的问题, 我们说`throw`**引发**了异常

* `try`语句块

  异常处理部分使用`try`语句处理异常, 以`try`关键字开始, 并以一个或者多个`catch`语句结束, `try`语句块中代码抛出的异常会被`catch`子句处理, 也被称为异常独立代码

* 一套**异常类(exception class)**, 用于在`throw`表达式和相关`catch`子句之间传递异常的具体信息

#### `throw`表达式

程序异常检测部分使用`throw`表达式引发一个异常. `throw`表达式包含关键字`throw`和紧随其后的一个表达式, 其中表达式的类型就是抛出的异常类型. `throw`表达式后面通常紧跟一个分号, 从而构成一条表达式

```c++
if (item1.isbn() != item2.isbn())
    throw runtime_error("Data must refer to the same ISBN");
// 代码会抛出异常终止当前函数, 并把控制权转移给处理该异常的代码
```

#### `try`语句块

```c++
try {
    statement
} catch (exception) {
    
} catch () {
    statement
}
```

`try`语句一开始关键字为`try`, 随后紧跟一个块. `catch`子句包括三部分: 关键字`catch`, 括号内的对象声明(称为**异常声明**)以及一个块. 当选中某个`catch`子句处理异常之后, 执行对应的块, `catch`一旦完成, 程序跳转`try`语句块最后一个`catch`之后的语句继续执行

##### 编写处理代码

```c++
try {
    if () throw exception(what);
} catch (exception e) {
    cerr << e.what() << endl;
}
```

`try`语句块对应一个`catch`子句负责处理某个类型的异常. `what`是`stdexception`的一个成员函数, 返回`c-style`字符串

##### 函数在寻找处理代码的过程中退出

可能存在多个`try`语句嵌套, 寻找处理代码的过程与函数调用链刚好相反. 当异常被抛出时, 首先搜索抛出该异常的函数, 如果还没有找到匹配的`catch`, 终止该函数, 然后再调用该函数的函数中继续寻找. 以此类推, 逐层退出, 如果最后还时没能找到任何匹配的`catch`子句, 程序转到名为`terninate`的标准库函数, 导致非正常退出.



#### 标准异常

* `exception`头文件定义了最通用的异常类`exception`, 只报告异常的发生, 不提供额外对的信息
* `stdexception`头文件定义了常用的异常类型
* `new`头文件`bad_alloc`异常类型
* `type_info`头文件定义了`bad_cast`异常类型

| `stdexcept`异常                                         |
| ------------------------------------------------------- |
| `exception`最常见问题                                   |
| `runtime_error`运行时错误                               |
| `range_error`运行时错误, 生成结果超出了有意义的值域范围 |
| `overflow_error`计算上溢出                              |
| `underflow_error`计算下溢出                             |
| `logic_error`程序逻辑错误                               |
| `domain_error`参数对应的结果值不存在                    |
| `invalid_argument`无效参数                              |
| `length_error`试图创建                                  |
| `out_of_range`超出一个超出有效范围的值                  |



## 函数

### 函数基础

一个典型的函数包括: 

* 返回类型
* 函数名字
* 形参列表
* 函数体

我们通过调用运算符或者说是括号运算符来执行函数.

##### 形参和实参

实参是形参的初始值

#### 局部对象

对象有生命周期

* 名字的作用域是程序文本的一部分, 名字在其中可见
* 对象的生命周期是程序执行过程中该对象存在的一段时间

形参和函数体内部定义的变量统称为**局部变量**, 同时局部变量还会隐藏外层作用域中同名的其他声明, 我们称之为**局部优先原则**

##### 自动对现象

对于普通的局部变量来讲, 我们把只存在于块执行期间的对象称为**自动对象**

##### 局部静态变量

将局部变量定义为`static`类型, 声明周期为整个程序运行期间, 统计函数自己被调用多少次, 如果局部变量没有显式初始值, 它将执行值初始化, 一般为`0`.



#### 函数声明

函数只能定义一次, 但是可以声明多次, 两者唯一区别是函数声明无需函数体, 函数声明也成为函数原型

##### 在头文件中进行函数声明

一般建议变量在头文件中进行声明, 在源文件中进行定义



#### 分离式编译



### 参数传递

按值传递和按引用传递

#### 按值传递

也就是额外拷贝副本

##### 指针形参

形参和实参不是同一个指针(位置不再同一个地方), 但是指向的值都是同一个.



#### 按引用传参

##### 使用引用避免拷贝

`IO`等类型不支持拷贝操作, 并且大的类型拷贝很低效. 当某种类型不支持`copy`操作的时候, 函数只能通过引用形参访问该类型的对象

> 如果函数无需改变引用形参的值, 最好将之声明为常量引用

##### 使用引用形参返回额外信息

也就是说我们的引用可以有`out`方向

#### `const`形参和实参

当实参初始化形参时会忽略掉顶层`const`, 也就是形参的顶层`const`会被忽略

```c++
int f(const int i) {
    return i;
}

int f(int i) {
    return i;
}

// 这种行为是错误的, 因为顶层const会被忽略, f(0)时编译器无法决定应该调用哪个函数
```

##### 指针或引用形参与`const`

这种和引用与指针的赋值方式具有相同的作用

##### 尽量使用常量引用

只要不改变其中的值都应该使用常量引用

#### 数组形参

实际上传递的是指针

##### 数组引用形参

```c++
void print(int (&arr)[10]) {
    for (auto elem : arr)
        cout << elem << endl;
}
// 数组引用可以保留数组的信息
```

#### 含有可变形参的函数

为了能编写处理不同数量实参的函数, `C++11`新标准提供了两种主要方法:

* 如果所有的实参类型相同, 可以传递一个名为`initialize_list`的标准库类型
* 如果实参类型不同, 可以编写一种特殊函数, 也就是所谓的可变参数模板

##### `initializer_list`形参

函数全部实参数量未知但是类型全部相同, 可以使用. `initializer_list<T> ls`对象中的元素永远是常量值, 无法修改

> 实际上本质就是一个`vector`, 初始化的方式采用列表初始化, 然后这个返回的对象是`const`, 因此无法修改返回的对象, `auto`可以自动类型推断



### 返回类型和`return`语句

返回值的方式和初始化变量或形参的方式完全一样: 返回值用于初始化调用点的一个临时值, 该临时量就是函数调用的结果.

如果函数返回引用, 则该引用仅是它所属对象的一个别名, 举个例子:

```c++
const string & shortString(const string &s1, const string &s2) {
    return s1.size() <= s2.size() ? s1 : s2;
}
```

实际上本质还是传递给一个临时变量, 然后临时变量再赋给断点处.

##### 不要返回局部对象的引用或指针

因为局部变量会被释放

##### 返回类类型的函数和调用运算符

优先从左到右结合

##### 引用返回左值

函数的返回类型决堤的那个函数调用时否时是左值. 调用一个返回引用的函数得到左值, 其它类型得到右值, 如果返回一个常量引用同样不能进行赋值操作.

##### 列表初始化返回值

`C++`标准规定, 函数可以返回花括号包围的值的列表. 类似于其它返回结果, 这个列表也用来表示函数返回的临时变量初始化. 可以返回空列表, 如果函数返回内置类型, 则花括号包围的列表最多包含一个值. 如果返回的是类类型, 由类本身定义初始值如何使用.

> 一般针对`vector`等可以列表初始化的类型

#### 返回数组指针

##### 声明一个返回数组指针的函数

```c++
int (*func(int i))[10]; // func是一个函数, 返回一个指针, 指针指向一个10个元素的int型数组
```

##### 使用尾置返回类型

`C++11`中可以简化上述`func`声明方式, 采用**尾置返回类型**(trailing return type). 任何函数定义都能使用尾置返回, 这种形式对应返回类型比较复杂的函数最有效, 比如返回类型是数组的指针, 或者数组的引用.

```c++
auto func(int i) -> int (*)[10];
// 前缀用auto代替, 将真正类型放置在->之后
```

##### 使用`decltype`

还有一种情况, 如果我们知道函数返回的指针将指向哪个数组, 就可以使用`decltype`关键字声明返回类型

```c++
int odd[] = {1, 3, 5, 7, 9};
int even[] = {0, 2, 4, 6, 8};
decltype(odd) *arrPtr(int i) {
    return (i % 2) ? &odd : &e
}
```



### 函数重载

如果同一个作用域内的几个函数名字相同, 但是形参列表不同, 我们称之为重载函数.

> `main`函数不能重载

##### 定义重载函数

仅有返回类型不同的函数不是重载, 编译器会报错.

##### 判断两个形参的类型是否相异

形参名会省略, 别名会被检测出来

##### 重载和`const`形参

顶层`const`不影响传入函数的对象. 一个拥有顶层`const`的形参和一个没有顶层`const`的形参无法区分

```c++
int f(const int i);
int f(int);

int f(int const *p);
int f(int *p);

// 上面两种函数无法区分
```

另一方面如果形参时某种类型的指针和引用, 则通过区分其是指向常量对象还是非常量对象可以实现重载, 此时`const`是底层的.

```c++
int f(const int &i);
int f(int &i);

int f(int *p);
int f(const int *p);
```

* 一种无法区分, 一种可区分:
  1. 无法区分: 顶层`const`和无顶层`const`
  2. 可区分: 底层`const`引用和普通引用
* 如果传递非常量对象, 编译器优先选择非常量版本



##### `const_cast`和重载

`const_cast`在重载函数中效果最好

```c++
const string& shorter(const string &s1, const string &s2) {
    return s1.size() > s2.size() ? s2 : s1;
}

string & shorter(string & s1, string & s2) {
    auto & r = shorter(const_cast<const string&>(s1), const_cast<const string&>(s2));
    return const_cast<string&>(r);
}
```



##### 调用重载的函数

函数匹配指的是一个过程, 把函数调用和函数重载关联起来叫做**重载确定**. 



#### 重载与作用域

一般来说, 函数声明放在一个局部作用域内不是一个明智的选择.

内层作用域中的声明名字, 将隐藏外层作用域中声明的同名实体, 在不同的作用域无法重载函数名.

### 特殊语言特性

#### 默认实参

把反复出现的值称为函数的默认实参, 调用时可以包含该实参也可以省略该实参

##### 使用默认实参调用函数

如果想要使用默认实参, 只需要在调用时省略该实参即可, 调用时按照位置解析. 省略的时候只能省略尾部的实参.

##### 默认实参声明

对于函数声明来讲, 通常习惯时将之放在头文件中, 并且一个函数只声明一次. 我们不能修改一个已经存在的默认值

> 给定的作用域中的一个形参只能被赋予一次默认实参, 也就是说后续的声明只能为那些之前还没有默认值的形参添加默认实参, 而且该形参右侧的所有形参都必须有默认值

##### 默认实参初始值

局部变量不能作为默认实参



#### 内联函数和`constexpr`函数

一般函数调用的过程会进行保留寄存器, 返回时恢复寄存器, 拷贝实参等耗时操作.

##### 内联函数可以避免函数调用的开销

将函数指定为内联函数, 就是将函数在调用点原地展开, 我们只需呀在函数的返回类型前加上关键字`inline`用来表示内联

> 内联只是向编译器发出的请求, 编译器可以进行忽略. 内联机制一般适合规模小, 流程直接, 调用频繁的函数



##### `constexpr`函数

`constexpr`函数是指能用于常量表达式的函数, 定义函数的方式与其它函数类似, 不过需要遵循几项约定:

* 函数返回类型以及所有的形参类型都必须时字面值类型
* 函数体中必须只有一条`return`语句

`constexpr`函数被隐式的指定为内联

> `constexpr`函数的返回值不一定是常量表达式, 这和我们传入参数的类型有关系, 只有传入常量或者表达式, 结果才会是常量表达式, 反之则不然



##### 把内联函数和`constexpr`函数放在头文件内

内联函数可以在程序中多次定义, 但是多个定义必须完全一致, 通常定义在头文件中.



#### 调试帮助

`C++`程序员有时想要采用头文件保护的技术， 以便有选择地执行调试代码



##### `assert`预处理宏

`assert`是一种**预处理宏**, 也就是编译器会在编译过程原地展开为一段代码

```c++
assert(expr)
```

首先对`expr`求值, 如果表达为假, `assert`输出信息并终止程序执行, 为真的话程序什么也不做.

`assert`宏定义在`cassert`头文件中, 预处理名字由预处理器进行管理而非编译器. 因此我们可以直接使用名字而无需提供`using`声明, 也就是说直接使用`assert`



##### `NDEBUG`

`assert`的行为依赖于一个名为`NDEBUG`的预处理变量状态, 如果定义了`NDEBUG`, 那么`assert`什么也不做, 默认状态下没有定义, 因此将会执行检查

我们可以使用一个`#define`语句定义`NDEBUG`, 从而关闭调试状态, 定义`NDEBUG`能避免检查各种条件所需的运行时开销, 当然此时根本不会执行运行时检查. 因此`assert`应该仅用于验证哪些确实不可能发生的事情. 我们可以把`assert`当成调试程序的一种辅助手段, 但是不能替代它成为真正的运行时逻辑检查, 也不能替代程序本身应该检查的错误.

> 真正的运行时逻辑检查还是应该自己检查, 并且采用异常的处理机制



##### 一些常用的调试定义

| `__func__` | 存放当前函数名的字符串字面值   |
| ---------- | ------------------------------ |
| `__LINE__` | 存放当前行号整型字面值         |
| `__TIME__` | 存放文件编译时间的字符串字面值 |
| `__DATE__` | 存放文件编译日期的字符串面值   |
| `__FILE__` | 存放当前文件名的字符串面值     |



### 函数匹配

##### 确定候选函数和可行函数

函数匹配过程为:

1. 选定本次调用对应的重载函数集, 集合中的函数称为**候选函数**. 候选函数具备两个特征: 一是与被调用的函数同名, 二是声明在调用点可见
2. 考察本次调用提供的实参, 然后从候选函数中选出能被这组实参调用的函数, 这些新选出的函数称为可行函数. 可行函数具备两个特征, 一是其形参数量与本次调用提供的实参数量相等(如果填了默认参数而满足调用关系的也计算在内), 二是每个实参的类型与对应的形参类型相同, 或者能转化为形参的类型.

##### 寻找最佳匹配(如果有的话)

实参类型和形参类型越接近, 它的匹配越好

##### 含有多个形参的函数匹配

当实参的数量有两个或者更多的时候

#### 实参类型转换

为了确定最佳匹配, 编译器将实参类型到形参的转换划分等级:

1. 精确匹配
   * 实参类型和形参类型相同
   * 实参从数组类型或函数类型转换成对应的指针类型
   * 向实参添加顶层`const`或者删除顶层`const`
2. 通过`const`转换实现匹配
3. 通过类型提升实现匹配
4. 通过算术类型转换或者指针转化
5. 通过类类型转换实现的匹配

> 所有算术转化的优先级都是相同的



### 函数指针

函数指针指向的是函数而非对象, 函数的类型由它的返回类型, 形参共同决定, 与函数名无关

##### 使用函数指针

当把函数名作为值使用的时候, 函数自动的转化为指针

```C++
bool lengthCmp(const string &, const string &);

bool (*f)(const string &, const string &);

auto pf = lengthCmp;
auto pf = &lengthCmp;
```

##### 函数指针作为形参

```c++
typedef bool Func(const string &, const string &);
typedef decltype(lengthCmp) Func;

typedef bool (*Func)(const string &, const string &);
typedef decltype(lengthCmp)* Func;
// 注意decltype只返回函数类型, 必须加上*才能转化为指针
```

##### 返回指向函数的指针

```c++
using F = int(int*, int); // 函数类型
using PF = int(*)(int*, int); // 函数指针
```

所以写的时候要么采用尾置返回类型和`decltype`

> `delctype`需要注意的是我们需要显式的添加*来表示指针



## 类

> 类的一些作用, 含义等不再赘述, 都不知道看多少遍了

##### `this`指向对象本身

##### `const`成员函数

函数之后紧跟`const`表示`this`是个常量指针, 也就是无法修改其内容. 这种函数被称为常量成员函数.

> 常量对象, 常量对象引用或指针都只能调用常量成员函数

##### 类作用域和成员函数

由于编译过程分两步处理类:

* 首先编译成员声明
* 成员函数

因此成员函数可以任意使用类中的其它成员而无须在意出现次序

##### 在类的外部定义成员函数

##### 定义一个返回`this`对象的函数

一般来讲当我们需要返回一个左值的时候我们会采用`this`, 那么返回类型应该采用引用的形式.

#### 定义类相关的非成员函数

通常把函数的声明和定义分开, 一般来说非成员函数是类接口的组成部分, 这些函数声明应该和类在同一个头文件中

`IO`类属于不可拷贝的的类型, 因此只能通过引用来传递它, 并且由于读取和写入操作会改变流的内容, 所以两个参数接受的都是普通引用, 而非常量引用.



#### 构造函数

只要类的对象被创建, 就会执行构造函数.

构造函数无法被声明为`const`, 当我们创建一个`const`对象时, 直到构造函数完成初始化过程, 对象才算真正取得了常量属性

##### 默认构造函数

编译器在没有构造函数的情况下会自动生成一个空的, 没有参数的构造函数.

但是默认构造函数并不总是可靠的, 有些情况下是无法创建默认构造函数

##### `= default`的含义

在`C++11`新标准中, 如果我们需要默认行为, 那么可以在参数列表后面写上`= default`来要求编译器生成构造函数, 这个声明即可以出现在类的外部, 也可以出现类的内部. **一般前提是我们执行类内初始化**

```c++
class T {
    int i = 0;
    int j = 0; // 类内初始化
    T() = default; // 默认行为的构造函数
};
```



##### 构造函数初始化列表

负责为新创建的对象的一个或几个数据成员赋初值. 构造函数初始值是成员名字的一个列表, 每个名字后面紧跟括号括起来成员初始值, 不同成员通过逗号分割.

通常来说, 构造函数采用类内初始值不失为一种好的选择, 因为只要这样的初始值存在, 我们就能确保为成员赋予了一个正确的值.

```c++
class T {
    string name = "";
    int i = 0;
    T() = default;
    T(const string & _s, int _i): name(s), i(_i) {}
};
```

##### 在类的外部定义构造函数

构造函数没有返回值



#### 拷贝, 赋值和析构

除了初始化, 类还需要控制拷贝, 赋值, 和销毁时对象发生的行为. 对象会在下列情况被拷贝(不全面):

* 初始化变量
* 以值的方式传递或返回一个对象

赋值运算符发生对象的赋值, 当对象不再存在的时候执行销毁动作.

> 如果我们不主动定义, 编译器会自动为我们生成默认版本

##### 某些类不能依赖合成版本

管理动态内存的时候无法依赖上述操作的合成版本.



### 访问控制和封装

**访问说明符**加强类的封装性:

* `public`说明成员对外部可见, 一般定义类的接口
* `private`说明成员对外部不可见, 一般定义类的数据成员

作为接口构造函数一般为`public`, 数据成员和实现一般`private`, 一个类可以包含0个或者多个访问说明符



##### 采用`class`和`struct`

`struct`默认权限是`public`, `class`默认权限是`private`



#### 友元

类允许其他类或者函数访问非公共有成员, 方法是令其它类或者函数称为它的**友元**, 如果类想要把一个函数作为它的**友元**, 只需要添加一条`friend`关键字开始的函数声明. **这个声明我们需要写在类中**, 实现可以写在函数外, 注意友元并非是类的成员.

> 一般最好在类的结束和开始集中声明友元, 不受类的访问权限控制

##### 友元的声明

友元的声明只是指定了访问权限, 而非一个通常意义上的函数声明. 如果我们希望类的用户能够调用某个友元函数, 那么我们就必须在友元声明之外再专门对函数进行一次声明.

为了使友元对类的用户可见, 我们通过把友元的声明与类本身放置在同一个头文件中, 为此我们需要单独再次提供声明.

> 也就是说我们在类里面声明的友元只是一种权限说明, 我是你的朋友. 真正的你还需要自己来声明和定义这个函数



### 类的其它特性

#### 类成员再探

一般来说类中的别名我们在`public`区进行声明, 这样使用户可见, **并且定义类型的成员必须先定义后使用**

```c++
class T
{
public:
    typedef ;
    using;
}
```

##### 令成员作为内联函数

一般类内部的成员函数默认内联, 你也可以显式声明`inline`, 当然也可以在类外部声明`inline`

##### 重载成员函数

和一般重载没有显著区别

##### 可变数据成员

有时我们希望能修改类的某个成员数据, 即使是在一个`const`成员内, 我们可以在变量声明中加入`mutable`关键字做到这一点. **可变数据成员**永远不会是`const`, 因此一个`const`成员函数可以改变一个`mutable`值

```c++
class T {
    mutable int i; // 指定i在const成员中也可改变
}
```

> 我所见过使用这种方式的出现在优化链表, `set_position`函数

##### 类数据成员的初始值

最好的方式是新标准中的类内初始化. 类内初始值必须采用`=`或者`{}`方式进行初始化



#### 返回`*this`的成员函数

采用返回左值的`*this`成员函数, 可以改变初始值的状态, 并进行连续操作.

```c++
T& returnThis() {
    return *this;
}
```



##### 从`const`成员函数返回`*this`

> 一个`const`成员函数如果以引用的方式返回`*this`, 那么返回类型将是常量引用



##### 基于`const`的重载

通过区分成员函数是否是`const`, 我们可以对其进行重载, 这和之前的顶层底层`const`的说法一致.

因此可见非常量对象优先调用非`const`函数, 而`const`对象优先调用`const`函数. 对象是否为`const`决定了应该调用那个版本.



#### 类类型

每个类都定义了唯一的类型, 对于两个类来说, 即使它们的成员完全一样, 这两个类也是不同的类型.

##### 类的声明

就像可以把函数声明和定义分离开一样, 我们也能仅声明类而暂时不定义它.

```c++
class T;
```

这种声明称为向前声明, 它向程序引入了名字, 并且指名了类型, 如果还没有定义, 那么它是一个不完全类. 允许这样的类产生指针和引用, 但是不允许类产生自己的类型.



#### 友元再谈

##### 类之间的友元关系

```c++
class T {
    friend class M;
};
```

如果一个类指定了友元类, 则友元类的成员函数可以访问此类包括非公有成员在内的所有成员.

> 需要注意, 友元关系不存在传递关系, 朋友的朋友不一定使朋友

##### 令成员函数作为友元

```c++
class T {
    friend void M::foo(parameter);
}
```

除了令整个类作为友元, 也可以指定为指定函数作为友元, 要想让某个成员函数作为友元, 我们必须要仔细组织程序的结构以满足声明和定义的彼此依赖关系

1. 首先定义友元函数所在的类, 其中声明友元函数, 但是不能定义
2. 定义要包含的友元函数的类, 声明友元成员函数
3. 最后再定义友元函数

##### 友元声明和作用域

> 友元声明只是影响权限访问控制, 并非真正意义上的声明, 因此声明还需要额外进行.



### 类的作用域

#### 名字查找和类的作用域

**名字查找**寻找与所用名字最匹配的声明的过程:

* 首先, 在名字所在的块中去寻找声明语句, 只考虑再名字使用之前声明的
* 如果没有找到, 继续外层查找
* 如果最终没有找到, 报错

对于类来说, 上述查找规则有所区别:

* 首先编译成员声明
* 直到类全部可见后编译函数体

> 编译器处理完类中的全部声明后才会处理成员函数定义

##### 用于类成员声明的名字查找

这两阶段的处理方式只适用于成员函数中使用的名字. 声明中使用的名字, 包括返回值类型, 或者参数列表中使用的名字, 都必须在使用前确保可见.

```c++
// 类型名, 别名必须要先出现
```

##### 特殊处理类型名

如果成员使用了外层作用域中的某个名字, 而该名字代表一种类型, 则类不能在之后重新定义该名字

```c++
typedef double Money;
class Account {
public:
    Money balance() { return bal; }
private:
    typedef double Money; // 错误, 无法重新定义
}
```

> 类型名的定义一般出现在类的开始处, 这样就能确保所有使用该类型的成员都出现在类名的定义之后



##### 成员定义中的普通块作用域的名字查找

成员函数中的名字查找按照如下方式解析:

* 首先在成员函数内查找该名字
* 如果成员函数内没找到, 到类内查找
* 如果内类没有则在作用域之前查找

##### 类作用域之后, 在外围的作用域中查找

如果我们希望使用外层作用域中的名字

```c++
::var; // 很不建议这样写;
```



### 构造函数再探

对于任何`C++`类来说, 构造函数都是最重要的组成部分

#### 构造函数初始化列表

**对对象成员来说, 如果没有在构造函数的初始值列表中显式的初始化成员, 则该成员将在构造函数体之前执行默认初始化.**

##### 构造函数的初始值有时必不可少

如果成员是`const`或者引用的化, 必须要将之初始化, 当成员属于某种类型, 并且该类型没有定义默认构造函数的时候, 也必须将这个成员初始化.

```c++
class ConstRef 
{
private:
    int i;
    const int ci;
    int &ri;
public:
    ConstRef(int ii);
};

ConstRef::ConstRef(int ii) {
    i = ii; // 正确
    ci = ii; // 错误, 无法被赋值
    ri = ii; // 错误, 五福初始化
}

ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(ii) {} // 正确

```

> Warning: 如果成员是`const`, 引用, 或者属于某种未提供默认构造函数的类类型, 我们必须通过构造函数初始值列表为这些成员提供初始值.
>
> 也就是说进行初始化的时候, 实际上首先首先看变量是否在初始化列表中(在初始化列表中的值不会执行默认初始化), 不在的话先执行默认初始化/类内初始化, 然后执行初始化列表, 最后才是函数体



> 建议使用构造函数初始值列表, 在很多类中初始化和赋值事关底层效率: 前者直接初始化数据成员, 后者则先初始化再赋值, 最后才执行函数体
>
> 除了效率之外, 一些数据成员必须初始化. 建议使用构造函数初始化列表



##### 成员初始化顺序

在构造函数初始值中华每个成员仅能出现一次. 构造函数初始值列表只说明用于初始化成员的值, 而不限定执行顺序.

**成员初始化顺序与他们在类中的定义出现顺序一致, 第一个成员先被初始化, 依次类推**



##### 默认实参和构造函数



#### 委托构造函数

新标准扩展了构造函数初始值的功能, 使得我们可以定义**委托构造函数delegating constructor**, 一个委托构造函数使用它所属类的其它构造函数执行自己的初始化过程, 或者说是它把自己的一些职责委托给了其它构造函数.

在委托构造函数中, 也有一个成员初始化列表和一个函数体, 在委托构造函数内, 成员初始值列表只有一个唯一的入口, 那就是类名本身, 参数列表必须和另外一个构造函数匹配.

> 执行顺序, 先执行委托函数及其函数体, 然后再执行本函数的函数体

#### 默认构造函数的作用

当对象被默认初始化或值初始化时自动执行默认构造函数, 默认初始化再以下情况发生:

* 再块作用域下不使用任何初始值定义一个非静态变量或者数组时
* 当类成员本身含有默认构造函数
* 当类成员没有再初始化列表中显式初始化

> 不多bb, 感觉没啥用



##### 使用默认构造函数

```c++
T a; // 默认初始化, 不要加括号
```



#### 隐式的类型转化

如果构造函数只接受一个实参, 则它实际上定义了转化为此类类型的隐式转化机制, 有时我们把这种构造函数称之为**转换构造函数**

##### 只允许一步转换

##### 类类型转换并不总是有效的

##### 抑制构造函数定义的隐式转换

我们可以将构造函数声明为`explicit`加以阻止, 这个关键字只对一个实参的构造函数有效, 并且只能在类内声明构造函数时使用, 在外部无须重复.

##### `explicit`构造函数只能用于直接初始化

发生隐式转换的一种情况是我们执行拷贝形式的初始化时

> 当我们采用`explicit`关键字声明构造函数的时候, 它将只能以直接初始化的形式使用, 而且编译器不会再自动转换过程中使用该构造函数



##### 为转换显式地使用构造函数

虽然不能隐式转换了, 但是我们可以显式转换.



#### 聚合类

**聚合类**允许可以直接访问其成员, 并且具有特殊地初始化语法形式, 聚合要求:

* 所有成员都是`public`
* 没有定义任何构造函数
* 没有类内初始化
* 没有基类, 也没有`virtual`函数

比如简单的`C struct`

我们可以提供一个花括号括起来表示成员初始化列表, 要注意顺序



#### 字面值常量类

某些类也是字面值类型, 字面值类型的类可能含有`constexpr`函数成员, 这样的成员必须符合`constexpr`函数的所有要求, 它们是隐式`const`

数据成员都是字面值类型的聚合类是字面值常量类. 如果一个类不是聚合类, 但是满足如下要求:

* 数据成员都是字面值类型
* 类必须至少含有一个`constexpr`构造函数
* 如果一个数成员含有类内初始化值, 则内置类型成员的初始值必须是常量表达式
* 类必须使用析构函数的默认定义, 该成员负责销毁类的对象           

`constexpr`构造函数必须要初始化所有成员数据, 初始值或者使用`constexpr`构造函数, 或者一条常量表达式, **意味着构造函数为空** 



### 类的静态成员

有的时候类需要它的一些成员与类本身直接相关, 而不是于类的各个对象保持关联.

##### 声明静态成员

我们通过在成员的声明之前加上关键字`static`使得其与类关联在一起, 和其他成员一样, 静态成员可以是`public`, 或者`protected`, 静态数据成员的类型可以是常量, 引用, 指针, 类等等.

类的静态成员存在于任何对象之外, 对象不包含任何与静态数据成员有关的数据. 类似的静态成员函数也不与任何对象`binding`在一起, 不包含`this`指针, 因此不能声明为`const`, 并且也不能在函数体内使用`this`指针

```c++
class T
{
public:
    static double insurance;
};
```

##### 使用类的静态成员

我们需要采用域运算符直接访问静态成员. 虽然静态成员不属于类的某个对象, 但是我们仍然可以使用类的对象, 引用或者指针来访问静态成员.

成员函数不用通过作用域运算符就能直接使用静态成员



##### 定义静态成员

我们既可以在类的外部也可以在内的内部定义静态成员函数, 当在类的外部定义静态成员时, 不能重复`static`关键字, 关键字只能出现在类的内部声明

因为静态数据成员不属于类的任何一个对象, 因此并不是在创建类的对象时时被定义的, 这意味着它们它们不是由类的构造函数初始化, 一般来说我们必须在类的外部定义并初始化每个静态成员.

```c++
T Class::member = something;
// 即使静态成员和函数都是私有的, 也能进行初始化
```

> 要想确保对象只定义一次, 最好的方法时把静态数据成员的定义和其它非内联函数的定义放在同一个文件中



##### 静态成员的类内初始化

通常情况下, 类的静态成员不应该在类的内部初始化. 然而, 我们可以为静态成员提供`const`整数类型的类内初始化.  不过要求静态成员必须时字面值常量类型的`constexpr`. 初始值必须是常量类型, 因为这些成员本身就是常量表达式

```c++
class T
{
private:
    static constexpr T var = exp; // 常量表达式, 适合编译器阶段的常量
}
```

> 如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况, 则一个初始化的`const`或者`constexpr static`不需要分别定义. 如果我们将它用于不能替换的场景中, 则该成员必须有一条定义语句.

> 即使一个`const static`数据成员在类内部初始化了, 通常情况下也应该在类的外部定义以下该成员.???



##### 静态成员能用于某些场合, 而普通成员不能

静态数据类型可以是不完全类型. 特别的, 静态数据成员的类型可以就是它所属的类类型, 而非静态数据成员则受到限制, 只能声明成它所属的指针或引用.

```c++
class Bar
{
public:
    //
private:
    static Bar mem1; // 正确
    Bar *meme2; // 正确
    Bar mem3; // 错误
}
```

另一个区别时静态成员可以作为默认实参

```c++
class Screen
{
public:
    Screen& clear(char = bkground);
private:
    static const char bkground;
}
```

非静态数据成员不能作为默认实参, 因为本身是对象的一部分.



## `C++`标准库

### `IO`类

| `iostream` | `istream`, `ostream`读写数据操作等等, 还有`w`的宽字符 |
| ---------- | ----------------------------------------------------- |
| `fstream`  | `ifstream`, `oftream`读写文件操作, `w`宽字符          |
| `sstream`  | `stringstream`, 读写`string`, 有`w`类型               |

为了支持使用宽字符, 标准库定义了`wchar_t`类型的数据, 这些都以`w`开头, 如`wcin`, `wcout`, `wcerr`等等

由于库之间采用继承的机制, 因此使用起来没有差别.



#### `IO`对象无拷贝或者赋值

```c++
ofstream o1, o2;
o1 = o2; // 无法赋值
ofstream p(o1); // 无法拷贝
// 因此一般采用引用的方式返回流对象, 并且不能设置为const, 因为流状态会改变;
```



#### 条件状态

`IO`操作一个与生俱来的问题是发生错误, 一些错误是可恢复, 而其它错误则发生系统深处, 超出了程序可以修复的范围, `IO`类定义一些函数, 可以访问和操纵流的**条件状态**.

| `strm::iostate`   | 机器相关的类型, 提供了表达条件状态的完整功能 |
| ----------------- | -------------------------------------------- |
| `strm::badbit`    | 指出流已经崩溃                               |
| `strm::failbit`   | 指出`IO`操作失败                             |
| `strm::eofbit`    | 指出流达到了文件结束                         |
| `strm::goodbit`   | 指出流未处于错误状态                         |
| `eof`             |                                              |
| `fail`            |                                              |
| `bad`             |                                              |
| `good`            |                                              |
| `clear`           | 将流的所有状态复位                           |
| `clear(flags)`    |                                              |
| `setstate(flags)` |                                              |
| `rdstate()`       |                                              |



## 格式化输出

### 重定向



### 使用`cout`进行输出

* 重载`<<`运算符

* 



### 格式化

* `setw(width)`设定输出宽度, 也就是右对齐的输出, 如果不足`width`将会自动填补空格

* `hex(cout)`或者`cout << hex`可以指定16进制输出, 同理含有`oct`八进制, `dec`十进制

* 字段宽度可以采用`cout.width(wid)`, 或者采用`cout << setw(wid)`来指定输出宽度, **警告`width`仅仅影响接下来的一个项目, 然后会恢复原状, 并且C++更注重内容**

* `cout.fill('')`可以用来填充控白

* 设置浮点数精度, 默认精度为6, `cout.precision(n)`可以用来表示精度, **它和`fill()`一样, 新的设置精度将会一直有效, 直到被重新设置, 自动四舍五入**

* 打印末尾的0和小数点, 采用`cout.setf(ios_base::showpoint)`

* `setf`详解

  仅设置一位

  | `ios_base::boolalpha` | 输入和输出bool值, 显式true和false |
  | --------------------- | --------------------------------- |
  | `showbase`            | 对于输出, 采用C++前缀`0`和`0x`    |
  | `showpoint`           | 显式末尾小数点                    |
  | `uppercase`           | 对于16进制采用大写字母            |
  | `showpos`             | 在正数前加`+`                     |

  设置两位

  第二个参数为`basefield`的时候:

  1. `dec`, `hex`, `oct`

  第二个参数为`floatfield`的时候

  1. `fixed`采用顶点计数法
  2. `scientific`采用科学计数法

  第二个参数为`adjustfield`的时候

  1. `left`表示左对齐
  2. `right`表示右对齐
  3. `internal`符号或者基数前缀对齐, 值右对齐



### 头文件`iomanip`

* `setfill(char)`设置填充值, 注意宽度是从输出之后开始进行



### 简单的文件I/O

要让程序写入文件, 必须要这样做:

* 创建一个`oftream`对象管理输出流
* 将该对象与特定的文件关联
* 以使用`cout`的方式使用该对象, 唯一区别是将输出进文件, 而不是屏幕

```c++
#include <fstream>
ofstream fout;
fout.open("file.txt");
ofstream fout("file.txt"); // 直接构造的时候使用

```

输入流的处理方式同理.

使用完之后要进行关闭



