# CPP-For-Future

> 这是一个面向未来的C++, 从C语言角度看C++

[toc]

## 基本概念



### 变量和基本数据类型

#### 内置基本类型

* 算术类型

  也就是基本的C语言数据类型以及后来的`bool`类型, 为了使C++具有更好的平台兼容性, 我们可以使用固定尺寸的数据类型, 例如: `int_32`, `int_64`等等

* 空类型

  `void`类型

* 有符号和无符号类型



> 基本上和C语言的类型没有太大差异

#### 类型转换

一般来说对于循环中的计数变量, 请不要将之定义为**无符号**类型.

##### 字面值常量

* 整型和浮点型字面值

  还是和C语言的一致

* 字符和字符串面值

* 转义序列

* 指定字面值类型

  1. `L`前缀指定`wchart_t`类型
  2. `u8`前缀指定字符串面值为`utf-8`格式
  3. `U`后缀指定无符号类型
  4. `u`前缀指定`unicode 16`字符, `U`前缀指定`unicode_32`字符
  5. `L`指定`long`类型



### 变量定义

变量的基本类型首先是**类型说明符**, 随后紧跟一个或者多个变量名组成的列表, 其中变量名以逗号分隔, 最后以分号结束

> 什么是对象?
>
> 对象是具有某种数据类型的内存空间

####  初始值

当对象在创建时获得了特定值, 称之为对象被**初始化**了

> 初始化不是赋值, 初始化的含义是创建变量时赋予其一个初始值, 而赋值的含义是把对象的当前值擦除, 而以一个新值来替代

#### 列表初始化

* 采用C语言`=`的方式进行初始化
* 采用花括号`{}`方式进行初始化, 这种初始化方式称为**列表初始化**, 这种初始化可以避免变量**窄缩**

####  默认初始化

如果定义变量时没有指定初始化值, 则变量将会**默认初始化**, 此时变量被赋予默认值, 这个值是什么由变量类型和定义位置决定.

* 如果内置类型未被显式初始化, 它的值由定义位置决定. **定义于任何函数体之外的变量被初始化为0**. 定义在函数体内部的内置类型变量将**不被初始化**, 也就是其中的值为**垃圾值**.
* 每个外部类自行决定初始化对象的方式, 绝大多数类都支持无须显式初始化而定义对象, 这样的类提供了合适的默认值., 例如`string`
* 还有一些类要求每个对象都显示初始化



#### 变量声明和定义关系

为了允许把程序拆分成多个逻辑部分来编写, `C++`支持**分离式编译**机制, 即将程序分割为若干文件, 每个文件可以独立编译; 为了将程序分为多个文件, 则需要在文件间共享代码的方法.

`C++`将声明和定义区分开. **声明**使得名字为程序所知, 一个文件如果想要使用别处定义的名字则必须包含对那个名字的声明. 而**定义**负责创建和名字关联的实体. 声明规定了变量的类型和名字, 而定义还申请存储空间, 也可能为变量赋值一个初始化值.

*  如果想声明一个变量而非定义它, 就在变量名前添加关键字`extern`, 任何包含了初始化的声明都会导致内存分配, 从而使声明变成定义.**尤其要注意一点, 变量只能定义一次, 但是可以多次声明**

> 静态类型
>
> `C++`是一种**静态类型**语言, 也就是在编译阶段检查类型. 其中, 检查类型的过程中称为**类型检查**




### 标识符

变量名规范继承了`C`语言的传统



### 作用域

同一个名字在不同的作用域可能指向不同的实体. 名字有效区域始于名字的声明语句, 以声明语句所在的作用域末端为结束. 而作用域以花括号`{}`进行定义

* 名字定义于所有的花括号之外拥有全局作用域, 从声明处开始具有域的范围
* 在同一个作用域存在多个同名变量的话采用**局部优先**原则



### 复合类型

基本的复合类型: **指针**和**引用**



#### 引用

一般的引用为**左值引用**, 引用相当于为**对象**另外起了一个名字, 采用`T &`来表示这是一个引用类型, 引用**必须在定义的时候初始化**, 定义引用时, 程序把引用和初始值**绑定binding**到一块, 也就是**别名**.

如果我们采用的是直接赋值, 相当于是在开辟了一个存储空间, 再将值**copy**到新内存当中.

> 由于引用本身不是一种类型, 只是一个别名, 因此不允许定义一个引用的引用(因为标准说不行)



特殊情况:

* 左值引用必须要对象进行绑定, 而不能和**字面值和表达式**绑定
* 左值引用必须要类型匹配



#### 指针

**指针**指向另外一种类型的的符合类型, 我想跳过这一节, 因为相比于`C`, 指针在`C++`没有太多扩展.

* 空指针不指向任何类型, 在试图对一个指针进行操作的时候首先要检查它是否为空, 采用`nullptr`来表示空指针. `nullptr`可以被转换为任意其它类型的空指针.
* `void*`指针, 它可以指向任何数据类型, 但是无法取对象, 因此取对象的时候我们需要进行强制转换

一般遇到类型复杂的时候, **我们采用从右向左读的方式进行类型解析**



### `const`限定符

`const`对象被创建之后它的值就不能被改变了, 所以它必须进行初始化

#### 默认情况下`const`对象仅在文件内有效

如果多个文件中都想使用`const`定义的变量, 我们必须在**每个使用到它的文件中都单独的进行定义**, 因此默认情况下**`const`被设定为仅在当前文件内有效**, 如果我们想要在多个文件中进行共享那么**不管定义还是声明我们都需要在它之前添加`extern`**

```c++
// file1.cpp中定义一个const常量
extern const int bufSize = fcn();

// file2.cpp中我们可以进行引用
extern const int bufSize;
```

#### `const`引用

可以把引用绑定到`const`对象上, 我们称之为**对`const`的引用**, 和普通引用所不同的是, 对常量的引用不能改变它所绑定的对象, 也就是这种引用表名**它所引用的对象都是常量, 包括基本类型**

#### 初始化和对`const`的引用

一般来说引用的类型必须要和所引用对象的类型保持一致, 但是存在两个例外:

1. 初始化常量引用的时候允许用任意表达式作为初始值, 只要该表达式的结果能转换成引用的类型即可. 尤其, 允许一个常量引用绑定非常量的对象, 字面值甚至一般表达式

   可是该如何理解这种行为呢? 实际上编译器做了优化

   ```c++
   double dval = 3.14;
   const int & ri = dval;
   // 上面是一个很正确的C++引用的赋值
   
   // 实际上编译器做了如下的优化
   const int temp = dval;
   const int &ri = temp;
   // 也就是在引用过程中产生了一个临时的整型常量, 也就是所说的临时量
   ```

   **临时量**就是引用表达式, 和类型不匹配时编译器的解决方法

2. 对`const`的引用可能并非引用一个`const`对象



#### 指针和`const`

这一点和`C`语言并没有什么不同, `const`在前表示指向的值无法改变, `const`在后表示指针无法被改变;

`const`指针意味着指向常量的指针, 因此可以用指向**常量**



### 顶层`const`

**顶层`const`**表示指针本身是一个常量, **底层`const`**表示指针所指的对象为一个常量, **因此, 我们可以通过判断变量本身是否可变来表示顶层和底层**(自己最大)



### `constexpr`和常量表达式

**常量表达式**是指值不会改变并且在编译过程就能得到计算结果的表达式. 显然字面值属于常量表达式. 采用常量表达式初始化的`const`对象也是常量表达式.

一个对象是不是常量表达式由它的数据类型和初始值共同决定, 例如:

```c++
const int max_files = 20; // max_file常量表达式
const int limit = max_file + 1; // limit是常量表达式
int staff_size = 27; // 不是常量表达式
```

#### `constexpr`变量

允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式. **声明为`constexpr`的变量一定是一个常量, 而且必须用常量表达式初始化**:

```c++
constexpr int mf = 20;
constexpr int limit = mf + 1;
constexpr int sz = size(); // 只有当size是一个constexpr函数时才是一条正确的声明语句
```

新标准允许定义一种特殊`constexpr`函数, 这种函数简单到足以在编译的时候就计算结果, 这样就能用`constexpr`函数去初始化`constexpr`变量了.

> 一般来说, **如果你认为变量是一个常量表达式, 那么就把它声明为`constexpr`类型**



### 字面值类型

常量表达式的值在编译时就得到计算, 因此对声明`constexpr`时用到的类型必须有所限制, 一般把这些类型称为**字面值类型**. 到目前为止接触过的数据类型中:

* 算术类型
* 引用
* 指针

都属于字面值类型. **尽管指针和引用都能定义成`constexpr`**, 但`constexpr`指针的初始值必须是`nullptr`或者`0`, 或者是存储于某个固定地址中对象.  函数体内定义的变量一般来说并非存放在**固定地址中**, 因此`constexpr`指针不能指向这样的变量. 定义于所有函数体之外的对象其地址**固定不变**. 因此`constexpr`能绑定到这样的变量上, `constexpr`指针也能指向这样的变量.



#### 指针和`constexpr`

在`constexpr`声明中如果定义了一个指针, 限定符`constexpr`仅对指针有效, 与指针所指的对象无关

```c++
constexpr int *q = nullptr; // q是一个指向整数的常量指针
// q是一个常量指针, constexpr把它所定义的对象置为了顶层const
```



### 处理类型

#### 类型别名

**类型别名**是否中类型的同义词, 可以让复杂类型名字变得简单明了, 易于理解和使用, 有两种方法可用于定义类型别名:

* `typedef`

  ```c++
  typedef double wages;
  typedef wages base, *p;
  ```

  `typedef`作为声明语句前缀之后, 变量名就代表了类型别名, 这里和`C`的用法一致.

* `using`

  新标准规定了**别名声明**来定义类型的别名

  ```c++
  using SI = Sales_item; // SI是Sales_item的同义词
  ```

  这种方法用关键字`using`作为别名声明的开始, 其后紧跟别名和等号, 其作用是把等号左侧的名字规定成等号右侧类型的别名.

#### 指针, 常量和类型别名

```c++
typedef char *pstring;
const pstring cstr = 0; // cstr是指向char的常量指针
const pstring *ps; // ps是一个指针, 它的对象是指向char的常量指针
```

可以这样解释: `pstring`是一个指向`char`的指针, 那么`const pstring cstr = 0`就是一个常量指针指向`char`



### `auto`类型说明符

可以让编译器代替我们去分析表达式所属的类型, 显然`auto`定义的变量必须要有初始值.

#### 符合类型, 常量和`auto`

* 遇到引用时, 以引用中值的类型作为`auto`类型

* `auto`会忽略掉**顶层`const`**, 同时**底层`const`**会被保留下来, 比如**指向常量的指针**

  ```c++
  const int ci = i, &cr = ci;
  auto b = ci; // b是一次整数
  auto c = cr; // c是一个整数
  auto d = &i; // d是一个整型指针
  auto e = &ci; // e是一个指向整型常量的指针(对常量对象取地址是一种底层const)
  ```

* 如果希望`auto`推断出顶层`const`, 需要指出

  ```c++
  const auto f = ci; // ci为int, f是const int
  ```

* 还可以将引用类型设为`auto`

  ```c++
  auto &g = ci; // g是一个整型常量引用
  auto &h = 42; 
  const auto &j = 42;
  ```




### `decltype`类型指示符

希望从表达式的类型推断出要定义的变量的类型， 但是不想用该表达式的值初始化变量， 为了满足这一个需求， `decltype`就可以大显身手, 它的作用时选择并返回操作数的数据类型:

```c++
decltype(f()) sum = x; // sum的类型就是函数f返回值类型
```

`decltype`处理顶层`const`和底层`const`的方法和`auto`有所不同, 如果`decltype`使用的表达式是一个变量, 那么`decltype`返回该变量的类型(包括顶层和引用)

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0;
decltype(cj) y = x;
decltype(cj) z; // 错误, 必须要初始化
```

#### `decltype`和引用

如果`decltype`使用的表达式不是一个变量, 则`decltype`返回表达式结果对应的类型, `decltype`的

```c++
int i = 32, *p = &i, &r = i;
decltype(r + 0) b; // 正确, 加法的结果是int, 因此b是一个未初始化的int
decltype(*p) c; // 错误, c是int &, 必须初始化
```

因为`r`是一个引用, 因此`decltype(r)`的结果是一个引用类型, 如果想要变成值类型, 可以将它作为表达式的一部分, 也就是说**如果`decltype`使用的表达式不是一个变量, 则`decltype`**返回表达式结果对应 的类型.

如果表达式的内容是一个解引用的操作, **那么就会产生引用类型, 因为这种类型可以改变原本的值, 所以选的是引用**

`decltype`和`auto`的另一个重要的区别是, `decltype`的结果和表达式形式密切, 如果`decltype`使用一个不加括号的变量, 则得到的就是该变量的类型, 如果变量加上了括号, 编译器就会把它当作一个表达式, 变量是一种可以作为赋值语句的特殊表达式, 所以这样的`decltype`就得到引用:

```c++
// decltype的表达式加上了括号变量, 结果将是引用
decltype((i)) d; // 错误, d是int&, 必须初始化
```

> 切记: `decltype((variable))`永远是引用, 而`decltype(variable)`结果只有当`variable`本身就是引用时才是引用



### 自定义数据结构

#### 类的数据成员

**数据成员**定义了类对象的具体内容, 每个对象都有一份数据成员copy, , 修改一个成员不会影响其余的成员

新标准规定, 可以为数据成员提供一个**类内初始化值**, 创建对象时, 类内初始化值将用于初始化值用于初始化数据成员. 没有初始化的成员将被默认初始化.



### 编写自己的头文件

类一般都不定义在函数体内, 挡在函数体外部定义类的时候, 在各个指定的源文件中可能只有一处该类的定义. 而且, 如果要在不同的文件中使用同一个类, 类的定义就必须保持一致.

头文件通常包含那些只能被定义一次的实体, 如类, `const`和`constexpr`变量



### 预处理器概念

确保头文件多次包含仍能安全工作的常用奇数时**预处理器**, 由`C++`语言从`C`语言继承而来, 一般采用`#ifndef`和`#define`以及`#endif`来防止头文件重复包含



## 字符串, 向量和数组



### 命名空间的`using`声明

我们用到的库函数基本都属于命名空间`std`, 作用域操作符`::`的含义时: 编译器应该从操作符左侧名字所示的作用域中寻找右侧那个名字, 但是**`using`声明**会将之边的简单. 

```c++
using namespace::name; // 可以直接访问命名空间的名字
```



#### 每个名字都需要独立的`using`声明

#### 头文件不应该包含`using`声明

如果头文件里有某个`using`声明, 那么每个使用了该头文件就会有这个声明. 对应某些程序, 可能会产生冲突.



### 标准库类型`string`

#### 常规操作

* 定义和初始化

  ```c++
  string str(10, 'c') // 表示10个c
  ```

* `=`表示拷贝初始化, 把等号右侧的初始值直接拷贝到左边, 实际上是先创建一个临时对象

* 如果不使用等号, 那么执行的时候**直接初始化**. 效率更高

* `getline()`作为`string`的输入流函数, 自动忽略空行, 也就是按行输入, 直到遇到换行符为止, 因此不包含`空行`

* `cin`按单词输入, 会自动忽略空行和空格

* `while(cin >> str)`可以用作不定数目的输入

* `string::size_type`表示长度的尺寸, 这里允许我们使用`auto`进行自动推断

* 处理`string`对象中的字符, 采用头文件中的`cctype`头文件定义标准库函数处理

* 处理每个字符, 采用基于范围的`for`循环

  ```c++
  for (dec: expr)
      statement
  ```

  使用范围`for`循环改变字符串中的字符, 可以把循环变量改变曾引用的格式, 这样就可以改变循环中的值, 转换为大写

### 标准库`vector`

表示对象的集合, 其中所有对象的类型都相同, 索引用于访问对象, 也称为**vector**, `C++`既有类模板, 也有函数模板, `vector`是一个类模板. 编译器根据模板创建类或者函数的过程称为**实例化**                      

#### 基本操作

* 定义和初始化操作

  ```c++
  // 只说明我没有见过的
  vector<T> v1;
  vector<T> v2(v1); // 直接初始化
  vector<T> v3(n, val); // 包含n个val
  vector<T> v4(n); // 包含n各个执行了初始化的对象
  vector<T> v5{a, b, c}; // 显式初始化赋值, 称为列表初始化
  ```

  `C++`提供了多种初始化方式, 第一个是拷贝初始化, 其次还有类内初始化,只能使用拷贝初始胡和花括号的形式, 以及列表初始化

  > 列表初始化会兼容()初始化

* 动态`push_back`效率更高

* 无法采用下标方式添加元素



### 迭代器介绍

迭代器提供了对象的间接访问, 有效的迭代器或者指向或者指向某个元素, 或者指向容器中尾元素的下一个位置, 其它所有情况都属于无效.

#### 使用迭代器

`begin`指向第一个元素的迭代器, `end`负责返回**尾元素的下一个位置**的迭代器, 也就是说该迭代器指示的容器的本不存在的**尾后**

##### 迭代器运算符

采用`==`和`!=`来比较两个合法迭代器相等

| `*iter` 所指元素的引用       |
| ---------------------------- |
| `iter->mem` 解引用并获取成员 |
| `++iter`指向下一个元素       |
| `--iter`指向上一个元素       |
| `==` 和`!=`判断相等          |

#### 迭代器类型

`vector<T>::iterator it`可以读写的迭代器, `vector<T>::const_iterator`只读元素



##### `begin`和`end`

返回类型有对象是否为常量决定, 如果为常量就返回只读, 否则返回普通的, 后来添加的`cbegin`和`cend`一定返回的是`const`类型



> 切记: 但凡是使用了迭代器的循环体, 都不要向迭代器所属的容器添加元素, 因为动态增长会是迭代器失效

##### 迭代器的算术运算

一直支持这种迭代器运算的的序列一般为顺序序列.



### 数组

数组也是存放类型相同的对象的容器, 但是这些对象需要通过位置访问, 数组的大小确定不变, 无法向其中增加元素, 性能比较好

> 数组的维度必须是一个常量表达式, 即`constxpr`类型

**这个部分由于和`C`过于类似, 所以不再细谈**

#### 标准库中的`begin`和`end`

新标准引入了`begin()`和`end()`函数, 一个返回组数的首元素地址, 另一个返回尾后元素地址



### `C`-style字符串

用法和`C`相同, 不再一一进行解释



### 多维数组

实际上是数组的数组, 阅读时由内向外推导





## 表达式

### 基础

#### 基本概念

基本使用和`C++`一样, 整型提升, 运算符结合顺序和结合性都是已经定义好的.

##### 左值和右值

基本概念是左值可以出现在赋值运算的左边, 右值可以出现在赋值运算的右边

**标准理解: 左值是指在内存中存在实际位置的对象, 可以理解成对于这个对象可以进行取地址运算,所有非左值都是右值.**

当一个对象被用作右值的时候, 采用的是对象中的值, 当对象被用作左值的时候, 用的是对象的身份(在内存中的位置), 当对象被用作左值的时候， 用的是对象的身份.

下面是几种常用的左值:

* 赋值运算符需要一个(非常量左值)作为其左侧运算对象, 得到的结果也仍然是一个左值
* **取地址运算符作用于一个左值运算对象, 返回一个指向该运算对象的指针, 指针是一个右值**
* 内置解引用运算符, 下标运算符, 迭代器解引用运算符的求值结果都是左值
* 内置类型和迭代器类型的递增递减运算符都作用域左值对象, 前置版本所得的结果也是左值

尤其使用关键字`decltype`的时候, 如果表达式所求值结果是左值, 那么关键字作用时得到一个引用类型

```c++
int i = 0;
int *p = &i;
decltype(*p) m = i; // 实际上会产生引用类型
decltype(&p) c; // 由于取地址运算符产生右值, 所以c是int**
```

#### 优先级和结合律

基本上和`C`的没有什么大不同, 求值顺序一般是未定义的

#### 求值顺序

`C++11`新标准规定商一律向0取整.



### 赋值运算符

`C++`新标准允许使用花括号括起来的初始化列表作为赋值语句的右侧运算对象, 对于`vector`也照样适用.

##### 赋值运算符的优先级较低

优先级`[] () . ->`是最高优先级, 其次是单目运算符, `++ *`

##### 前置版本的递增运算符效率要更高一点, 并且更符合变成规范

一种很重要的省略, `*p++`, 由于结合性的原因, 实际上等同于`*(p++)`

`++`后置是先运算, 再加; `++`前置是先加, 再运算



### 成员访问运算符

`.`和`->`运算符, 箭头运算符作用一个指针类型的运算对象, 结果是一个左值. 点运算分成两种情况, 如果成员所属的对象是左值, 那么结果是左值; 反之如果成员所属的对象是右值, 那么结果也是右值



### `sizeof`运算符

返回一个类型所占字节数, `sizeof`可以作用无效指针的解引用, 因为它不计算值, 它只进行推断



### 逗号运算符

最后一个表达式作为返回值



### 类型转换

#### 隐式类型转换

和`C`语言基本一致, 因此不再赘述

#### 显式类型转换

##### 命名的强制类型转换

格式如下:

```cpp
cast-name<type>(expression);
```

其中`type`是转换的目标类型而`expression`是要转换的值, 如果`type`是引用类型, 则结果是左值类型. `cast-name`是`static_cast`, `dynamic_cast`和`const_cast`和`reinterpret_cast`中的一种.

* `static_cast`任何具有明确定义的类型转换, 只要不包含底层`const`, 都可以使用`static_cast`, 在把一个较大的算术类型赋值给较小的类型的时候, 非常有用, 此时强制类型转换告诉编译器我不在乎可能会丢失的精度

* `const_cast`只能改变运算对象的底层`const`

  ```c++
  const char *pc;
  char *p = const_cast<char*>(pc); // 将底层const转换为普通
  ```

  我们称之为去掉`const`性质, 一旦我们去掉了`const`性质, 也仅有`const_cast`可以改变常量属性. 常常用于有函数重载的上文文当中.

* `reinterpret_cast`

  通常为运算对象的位模式提供较低层次上的重新解释, 很危险, 一般用在底层的罗基范以上



### 运算符优先级

| ::     |
| ------ |
| .      |
| ->     |
| []     |
| ()     |
| ++     |
| --     |
| typeid |



## 语句

### 简单语句

略

#### 范围`for`语句

```c++
for (decl: exp)
    statement;
```

`exp`必须要实现迭代器



### `try`语句块和异常处理

异常是指存在运行时的反常行为, 处理一行行为时所有系统设计最难的一部分. 异常处理机制为程序中**异常检测**和**异常处理**这两部分的协作提供支持, `C++`处理包括:

* `throw`表达式

  异常检测部分使用`throw`表达式来表示它遇到了无法处理的问题, 我们说`throw`**引发**了异常

* `try`语句块

  异常处理部分使用`try`语句处理异常, 以`try`关键字开始, 并以一个或者多个`catch`语句结束, `try`语句块中代码抛出的异常会被`catch`子句处理, 也被称为异常独立代码

* 一套**异常类(exception class)**, 用于在`throw`表达式和相关`catch`子句之间传递异常的具体信息

#### `throw`表达式

程序异常检测部分使用`throw`表达式引发一个异常. `throw`表达式包含关键字`throw`和紧随其后的一个表达式, 其中表达式的类型就是抛出的异常类型. `throw`表达式后面通常紧跟一个分号, 从而构成一条表达式

```c++
if (item1.isbn() != item2.isbn())
    throw runtime_error("Data must refer to the same ISBN");
// 代码会抛出异常终止当前函数, 并把控制权转移给处理该异常的代码
```

#### `try`语句块

```c++
try {
    statement
} catch (exception) {
    
} catch () {
    statement
}
```

`try`语句一开始关键字为`try`, 随后紧跟一个块. `catch`子句包括三部分: 关键字`catch`, 括号内的对象声明(称为**异常声明**)以及一个块. 当选中某个`catch`子句处理异常之后, 执行对应的块, `catch`一旦完成, 程序跳转`try`语句块最后一个`catch`之后的语句继续执行

##### 编写处理代码

```c++
try {
    if () throw exception(what);
} catch (exception e) {
    cerr << e.what() << endl;
}
```

`try`语句块对应一个`catch`子句负责处理某个类型的异常. `what`是`stdexception`的一个成员函数, 返回`c-style`字符串

##### 函数在寻找处理代码的过程中退出

可能存在多个`try`语句嵌套, 寻找处理代码的过程与函数调用链刚好相反. 当异常被抛出时, 首先搜索抛出该异常的函数, 如果还没有找到匹配的`catch`, 终止该函数, 然后再调用该函数的函数中继续寻找. 以此类推, 逐层退出, 如果最后还时没能找到任何匹配的`catch`子句, 程序转到名为`terninate`的标准库函数, 导致非正常退出.



#### 标准异常

* `exception`头文件定义了最通用的异常类`exception`, 只报告异常的发生, 不提供额外对的信息
* `stdexception`头文件定义了常用的异常类型
* `new`头文件`bad_alloc`异常类型
* `type_info`头文件定义了`bad_cast`异常类型

| `stdexcept`异常                                         |
| ------------------------------------------------------- |
| `exception`最常见问题                                   |
| `runtime_error`运行时错误                               |
| `range_error`运行时错误, 生成结果超出了有意义的值域范围 |
| `overflow_error`计算上溢出                              |
| `underflow_error`计算下溢出                             |
| `logic_error`程序逻辑错误                               |
| `domain_error`参数对应的结果值不存在                    |
| `invalid_argument`无效参数                              |
| `length_error`试图创建                                  |
| `out_of_range`超出一个超出有效范围的值                  |



## 函数

### 函数基础

一个典型的函数包括: 

* 返回类型
* 函数名字
* 形参列表
* 函数体

我们通过调用运算符或者说是括号运算符来执行函数.

##### 形参和实参

实参是形参的初始值

#### 局部对象

对象有生命周期

* 名字的作用域是程序文本的一部分, 名字在其中可见
* 对象的生命周期是程序执行过程中该对象存在的一段时间

形参和函数体内部定义的变量统称为**局部变量**, 同时局部变量还会隐藏外层作用域中同名的其他声明, 我们称之为**局部优先原则**

##### 自动对现象

对于普通的局部变量来讲, 我们把只存在于块执行期间的对象称为**自动对象**

##### 局部静态变量

将局部变量定义为`static`类型, 声明周期为整个程序运行期间, 统计函数自己被调用多少次, 如果局部变量没有显式初始值, 它将执行值初始化, 一般为`0`.



#### 函数声明

函数只能定义一次, 但是可以声明多次, 两者唯一区别是函数声明无需函数体, 函数声明也成为函数原型

##### 在头文件中进行函数声明

一般建议变量在头文件中进行声明, 在源文件中进行定义



#### 分离式编译



### 参数传递

按值传递和按引用传递

#### 按值传递

也就是额外拷贝副本

##### 指针形参

形参和实参不是同一个指针(位置不再同一个地方), 但是指向的值都是同一个.



#### 按引用传参

##### 使用引用避免拷贝

`IO`等类型不支持拷贝操作, 并且大的类型拷贝很低效. 当某种类型不支持`copy`操作的时候, 函数只能通过引用形参访问该类型的对象

> 如果函数无需改变引用形参的值, 最好将之声明为常量引用

##### 使用引用形参返回额外信息

也就是说我们的引用可以有`out`方向

#### `const`形参和实参

当实参初始化形参时会忽略掉顶层`const`, 也就是形参的顶层`const`会被忽略

```c++
int f(const int i) {
    return i;
}

int f(int i) {
    return i;
}

// 这种行为是错误的, 因为顶层const会被忽略, f(0)时编译器无法决定应该调用哪个函数
```

##### 指针或引用形参与`const`

这种和引用与指针的赋值方式具有相同的作用

##### 尽量使用常量引用

只要不改变其中的值都应该使用常量引用

#### 数组形参

实际上传递的是指针

##### 数组引用形参

```c++
void print(int (&arr)[10]) {
    for (auto elem : arr)
        cout << elem << endl;
}
// 数组引用可以保留数组的信息
```

#### 含有可变形参的函数

为了能编写处理不同数量实参的函数, `C++11`新标准提供了两种主要方法:

* 如果所有的实参类型相同, 可以传递一个名为`initialize_list`的标准库类型
* 如果实参类型不同, 可以编写一种特殊函数, 也就是所谓的可变参数模板

##### `initializer_list`形参

函数全部实参数量未知但是类型全部相同, 可以使用. `initializer_list<T> ls`对象中的元素永远是常量值, 无法修改

> 实际上本质就是一个`vector`, 初始化的方式采用列表初始化, 然后这个返回的对象是`const`, 因此无法修改返回的对象, `auto`可以自动类型推断



### 返回类型和`return`语句

返回值的方式和初始化变量或形参的方式完全一样: 返回值用于初始化调用点的一个临时值, 该临时量就是函数调用的结果.

如果函数返回引用, 则该引用仅是它所属对象的一个别名, 举个例子:

```c++
const string & shortString(const string &s1, const string &s2) {
    return s1.size() <= s2.size() ? s1 : s2;
}
```

实际上本质还是传递给一个临时变量, 然后临时变量再赋给断点处.

##### 不要返回局部对象的引用或指针

因为局部变量会被释放

##### 返回类类型的函数和调用运算符

优先从左到右结合

##### 引用返回左值

函数的返回类型决堤的那个函数调用时否时是左值. 调用一个返回引用的函数得到左值, 其它类型得到右值, 如果返回一个常量引用同样不能进行赋值操作.

##### 列表初始化返回值

`C++`标准规定, 函数可以返回花括号包围的值的列表. 类似于其它返回结果, 这个列表也用来表示函数返回的临时变量初始化. 可以返回空列表, 如果函数返回内置类型, 则花括号包围的列表最多包含一个值. 如果返回的是类类型, 由类本身定义初始值如何使用.

> 一般针对`vector`等可以列表初始化的类型

#### 返回数组指针

##### 声明一个返回数组指针的函数

```c++
int (*func(int i))[10]; // func是一个函数, 返回一个指针, 指针指向一个10个元素的int型数组
```

##### 使用尾置返回类型

`C++11`中可以简化上述`func`声明方式, 采用**尾置返回类型**(trailing return type). 任何函数定义都能使用尾置返回, 这种形式对应返回类型比较复杂的函数最有效, 比如返回类型是数组的指针, 或者数组的引用.

```c++
auto func(int i) -> int (*)[10];
// 前缀用auto代替, 将真正类型放置在->之后
```

##### 使用`decltype`

还有一种情况, 如果我们知道函数返回的指针将指向哪个数组, 就可以使用`decltype`关键字声明返回类型

```c++
int odd[] = {1, 3, 5, 7, 9};
int even[] = {0, 2, 4, 6, 8};
decltype(odd) *arrPtr(int i) {
    return (i % 2) ? &odd : &e
}
```







## 格式化输出

### 重定向



### 使用`cout`进行输出

* 重载`<<`运算符

* 



### 格式化

* `setw(width)`设定输出宽度, 也就是右对齐的输出, 如果不足`width`将会自动填补空格

* `hex(cout)`或者`cout << hex`可以指定16进制输出, 同理含有`oct`八进制, `dec`十进制

* 字段宽度可以采用`cout.width(wid)`, 或者采用`cout << setw(wid)`来指定输出宽度, **警告`width`仅仅影响接下来的一个项目, 然后会恢复原状, 并且C++更注重内容**

* `cout.fill('')`可以用来填充控白

* 设置浮点数精度, 默认精度为6, `cout.precision(n)`可以用来表示精度, **它和`fill()`一样, 新的设置精度将会一直有效, 直到被重新设置, 自动四舍五入**

* 打印末尾的0和小数点, 采用`cout.setf(ios_base::showpoint)`

* `setf`详解

  仅设置一位

  | `ios_base::boolalpha` | 输入和输出bool值, 显式true和false |
  | --------------------- | --------------------------------- |
  | `showbase`            | 对于输出, 采用C++前缀`0`和`0x`    |
  | `showpoint`           | 显式末尾小数点                    |
  | `uppercase`           | 对于16进制采用大写字母            |
  | `showpos`             | 在正数前加`+`                     |

  设置两位

  第二个参数为`basefield`的时候:

  1. `dec`, `hex`, `oct`

  第二个参数为`floatfield`的时候

  1. `fixed`采用顶点计数法
  2. `scientific`采用科学计数法

  第二个参数为`adjustfield`的时候

  1. `left`表示左对齐
  2. `right`表示右对齐
  3. `internal`符号或者基数前缀对齐, 值右对齐



### 头文件`iomanip`

* `setfill(char)`设置填充值, 注意宽度是从输出之后开始进行



### 简单的文件I/O

要让程序写入文件, 必须要这样做:

* 创建一个`oftream`对象管理输出流
* 将该对象与特定的文件关联
* 以使用`cout`的方式使用该对象, 唯一区别是将输出进文件, 而不是屏幕

```c++
#include <fstream>
ofstream fout;
fout.open("file.txt");
ofstream fout("file.txt"); // 直接构造的时候使用

```

输入流的处理方式同理.

使用完之后要进行关闭



