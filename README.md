# CPP-For-Future

> 这是一个面向未来的C++, 从C语言角度看C++

[toc]

## 基本概念



### 变量和基本数据类型

#### 内置基本类型

* 算术类型

  也就是基本的C语言数据类型以及后来的`bool`类型, 为了使C++具有更好的平台兼容性, 我们可以使用固定尺寸的数据类型, 例如: `int_32`, `int_64`等等

* 空类型

  `void`类型

* 有符号和无符号类型



> 基本上和C语言的类型没有太大差异

#### 类型转换

一般来说对于循环中的计数变量, 请不要将之定义为**无符号**类型.

##### 字面值常量

* 整型和浮点型字面值

  还是和C语言的一致

* 字符和字符串面值

* 转义序列

* 指定字面值类型

  1. `L`前缀指定`wchart_t`类型
  2. `u8`前缀指定字符串面值为`utf-8`格式
  3. `U`后缀指定无符号类型
  4. `u`前缀指定`unicode 16`字符, `U`前缀指定`unicode_32`字符
  5. `L`指定`long`类型



### 变量定义

变量的基本类型首先是**类型说明符**, 随后紧跟一个或者多个变量名组成的列表, 其中变量名以逗号分隔, 最后以分号结束

> 什么是对象?
>
> 对象是具有某种数据类型的内存空间

####  初始值

当对象在创建时获得了特定值, 称之为对象被**初始化**了

> 初始化不是赋值, 初始化的含义是创建变量时赋予其一个初始值, 而赋值的含义是把对象的当前值擦除, 而以一个新值来替代

#### 列表初始化

* 采用C语言`=`的方式进行初始化
* 采用花括号`{}`方式进行初始化, 这种初始化方式称为**列表初始化**, 这种初始化可以避免变量**窄缩**

####  默认初始化

如果定义变量时没有指定初始化值, 则变量将会**默认初始化**, 此时变量被赋予默认值, 这个值是什么由变量类型和定义位置决定.

* 如果内置类型未被显式初始化, 它的值由定义位置决定. **定义于任何函数体之外的变量被初始化为0**. 定义在函数体内部的内置类型变量将**不被初始化**, 也就是其中的值为**垃圾值**.
* 每个外部类自行决定初始化对象的方式, 绝大多数类都支持无须显式初始化而定义对象, 这样的类提供了合适的默认值., 例如`string`
* 还有一些类要求每个对象都显示初始化



#### 变量声明和定义关系

为了允许把程序拆分成多个逻辑部分来编写, `C++`支持**分离式编译**机制, 即将程序分割为若干文件, 每个文件可以独立编译; 为了将程序分为多个文件, 则需要在文件间共享代码的方法.

`C++`将声明和定义区分开. **声明**使得名字为程序所知, 一个文件如果想要使用别处定义的名字则必须包含对那个名字的声明. 而**定义**负责创建和名字关联的实体. 声明规定了变量的类型和名字, 而定义还申请存储空间, 也可能为变量赋值一个初始化值.

*  如果想声明一个变量而非定义它, 就在变量名前添加关键字`extern`, 任何包含了初始化的声明都会导致内存分配, 从而使声明变成定义.**尤其要注意一点, 变量只能定义一次, 但是可以多次声明**

> 静态类型
>
> `C++`是一种**静态类型**语言, 也就是在编译阶段检查类型. 其中, 检查类型的过程中称为**类型检查**




### 标识符

变量名规范继承了`C`语言的传统



### 作用域

同一个名字在不同的作用域可能指向不同的实体. 名字有效区域始于名字的声明语句, 以声明语句所在的作用域末端为结束. 而作用域以花括号`{}`进行定义

* 名字定义于所有的花括号之外拥有全局作用域, 从声明处开始具有域的范围
* 在同一个作用域存在多个同名变量的话采用**局部优先**原则



### 复合类型

基本的复合类型: **指针**和**引用**



#### 引用

一般的引用为**左值引用**, 引用相当于为**对象**另外起了一个名字, 采用`T &`来表示这是一个引用类型, 引用**必须在定义的时候初始化**, 定义引用时, 程序把引用和初始值**绑定binding**到一块, 也就是**别名**.

如果我们采用的是直接赋值, 相当于是在开辟了一个存储空间, 再将值**copy**到新内存当中.

> 由于引用本身不是一种类型, 只是一个别名, 因此不允许定义一个引用的引用(因为标准说不行)



特殊情况:

* 左值引用必须要对象进行绑定, 而不能和**字面值和表达式**绑定
* 左值引用必须要类型匹配



#### 指针

**指针**指向另外一种类型的的符合类型, 我想跳过这一节, 因为相比于`C`, 指针在`C++`没有太多扩展.

* 空指针不指向任何类型, 在试图对一个指针进行操作的时候首先要检查它是否为空, 采用`nullptr`来表示空指针. `nullptr`可以被转换为任意其它类型的空指针.
* `void*`指针, 它可以指向任何数据类型, 但是无法取对象, 因此取对象的时候我们需要进行强制转换

一般遇到类型复杂的时候, **我们采用从右向左读的方式进行类型解析**



### `const`限定符

`const`对象被创建之后它的值就不能被改变了, 所以它必须进行初始化

#### 默认情况下`const`对象仅在文件内有效

如果多个文件中都想使用`const`定义的变量, 我们必须在**每个使用到它的文件中都单独的进行定义**, 因此默认情况下**`const`被设定为仅在当前文件内有效**, 如果我们想要在多个文件中进行共享那么**不管定义还是声明我们都需要在它之前添加`extern`**

```c++
// file1.cpp中定义一个const常量
extern const int bufSize = fcn();

// file2.cpp中我们可以进行引用
extern const int bufSize;
```

#### `const`引用

可以把引用绑定到`const`对象上, 我们称之为**对`const`的引用**, 和普通引用所不同的是, 对常量的引用不能改变它所绑定的对象, 也就是这种引用表名**它所引用的对象都是常量, 包括基本类型**

#### 初始化和对`const`的引用

一般来说引用的类型必须要和所引用对象的类型保持一致, 但是存在两个例外:

1. 初始化常量引用的时候允许用任意表达式作为初始值, 只要该表达式的结果能转换成引用的类型即可. 尤其, 允许一个常量引用绑定非常量的对象, 字面值甚至一般表达式

   可是该如何理解这种行为呢? 实际上编译器做了优化

   ```c++
   double dval = 3.14;
   const int & ri = dval;
   // 上面是一个很正确的C++引用的赋值
   
   // 实际上编译器做了如下的优化
   const int temp = dval;
   const int &ri = temp;
   // 也就是在引用过程中产生了一个临时的整型常量, 也就是所说的临时量
   ```

   **临时量**就是引用表达式, 和类型不匹配时编译器的解决方法

2. 对`const`的引用可能并非引用一个`const`对象



#### 指针和`const`

这一点和`C`语言并没有什么不同, `const`在前表示指向的值无法改变, `const`在后表示指针无法被改变;

`const`指针意味着指向常量的指针, 因此可以用指向**常量**



### 顶层`const`

**顶层`const`**表示指针本身是一个常量, **底层`const`**表示指针所指的对象为一个常量, **因此, 我们可以通过判断变量本身是否可变来表示顶层和底层**(自己最大)



### `constexpr`和常量表达式

**常量表达式**是指值不会改变并且在编译过程就能得到计算结果的表达式. 显然字面值属于常量表达式. 采用常量表达式初始化的`const`对象也是常量表达式.

一个对象是不是常量表达式由它的数据类型和初始值共同决定, 例如:

```c++
const int max_files = 20; // max_file常量表达式
const int limit = max_file + 1; // limit是常量表达式
int staff_size = 27; // 不是常量表达式
```

#### `constexpr`变量

允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式. **声明为`constexpr`的变量一定是一个常量, 而且必须用常量表达式初始化**:

```c++
constexpr int mf = 20;
constexpr int limit = mf + 1;
constexpr int sz = size(); // 只有当size是一个constexpr函数时才是一条正确的声明语句
```

新标准允许定义一种特殊`constexpr`函数, 这种函数简单到足以在编译的时候就计算结果, 这样就能用`constexpr`函数去初始化`constexpr`变量了.

> 一般来说, **如果你认为变量是一个常量表达式, 那么就把它声明为`constexpr`类型**



### 字面值类型

常量表达式的值在编译时就得到计算, 因此对声明`constexpr`时用到的类型必须有所限制, 一般把这些类型称为**字面值类型**. 到目前为止接触过的数据类型中:

* 算术类型
* 引用
* 指针

都属于字面值类型. **尽管指针和引用都能定义成`constexpr`**, 但`constexpr`指针的初始值必须是`nullptr`或者`0`, 或者是存储于某个固定地址中对象.  函数体内定义的变量一般来说并非存放在**固定地址中**, 因此`constexpr`指针不能指向这样的变量. 定义于所有函数体之外的对象其地址**固定不变**. 因此`constexpr`能绑定到这样的变量上, `constexpr`指针也能指向这样的变量.



#### 指针和`constexpr`

在`constexpr`声明中如果定义了一个指针, 限定符`constexpr`仅对指针有效, 与指针所指的对象无关

```c++
constexpr int *q = nullptr; // q是一个指向整数的常量指针
// q是一个常量指针, constexpr把它所定义的对象置为了顶层const
```



### 处理类型

#### 类型别名

**类型别名**是否中类型的同义词, 可以让复杂类型名字变得简单明了, 易于理解和使用, 有两种方法可用于定义类型别名:

* `typedef`

  ```c++
  typedef double wages;
  typedef wages base, *p;
  ```

  `typedef`作为声明语句前缀之后, 变量名就代表了类型别名, 这里和`C`的用法一致.

* `using`

  新标准规定了**别名声明**来定义类型的别名

  ```c++
  using SI = Sales_item; // SI是Sales_item的同义词
  ```

  这种方法用关键字`using`作为别名声明的开始, 其后紧跟别名和等号, 其作用是把等号左侧的名字规定成等号右侧类型的别名.

#### 指针, 常量和类型别名

```c++
typedef char *pstring;
const pstring cstr = 0; // cstr是指向char的常量指针
const pstring *ps; // ps是一个指针, 它的对象是指向char的常量指针
```

可以这样解释: `pstring`是一个指向`char`的指针, 那么`const pstring cstr = 0`就是一个常量指针指向`char`



### `auto`类型说明符

可以让编译器代替我们去分析表达式所属的类型, 显然`auto`定义的变量必须要有初始值.

#### 符合类型, 常量和`auto`

* 遇到引用时, 以引用中值的类型作为`auto`类型

* `auto`会忽略掉**顶层`const`**, 同时**底层`const`**会被保留下来, 比如**指向常量的指针**

  ```c++
  const int ci = i, &cr = ci;
  auto b = ci; // b是一次整数
  auto c = cr; // c是一个整数
  auto d = &i; // d是一个整型指针
  auto e = &ci; // e是一个指向整型常量的指针(对常量对象取地址是一种底层const)
  ```

* 如果希望`auto`推断出顶层`const`, 需要指出

  ```c++
  const auto f = ci; // ci为int, f是const int
  ```

* 还可以将引用类型设为`auto`

  ```c++
  auto &g = ci; // g是一个整型常量引用
  auto &h = 42; 
  const auto &j = 42;
  ```




### `decltype`类型指示符

希望从表达式的类型推断出要定义的变量的类型， 但是不想用该表达式的值初始化变量， 为了满足这一个需求， `decltype`就可以大显身手, 它的作用时选择并返回操作数的数据类型:

```c++
decltype(f()) sum = x; // sum的类型就是函数f返回值类型
```

`decltype`处理顶层`const`和底层`const`的方法和`auto`有所不同, 如果`decltype`使用的表达式是一个变量, 那么`decltype`返回该变量的类型(包括顶层和引用)

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0;
decltype(cj) y = x;
decltype(cj) z; // 错误, 必须要初始化
```

#### `decltype`和引用

如果`decltype`使用的表达式不是一个变量, 则`decltype`返回表达式结果对应的类型, `decltype`的

```c++
int i = 32, *p = &i, &r = i;
decltype(r + 0) b; // 正确, 加法的结果是int, 因此b是一个未初始化的int
decltype(*p) c; // 错误, c是int &, 必须初始化
```

因为`r`是一个引用, 因此`decltype(r)`的结果是一个引用类型, 如果想要变成值类型, 可以将它作为表达式的一部分, 也就是说**如果`decltype`使用的表达式不是一个变量, 则`decltype`**返回表达式结果对应 的类型.

如果表达式的内容是一个解引用的操作, **那么就会产生引用类型, 因为这种类型可以改变原本的值, 所以选的是引用**

`decltype`和`auto`的另一个重要的区别是, `decltype`的结果和表达式形式密切, 如果`decltype`使用一个不加括号的变量, 则得到的就是该变量的类型, 如果变量加上了括号, 编译器就会把它当作一个表达式, 变量是一种可以作为赋值语句的特殊表达式, 所以这样的`decltype`就得到引用:

```c++
// decltype的表达式加上了括号变量, 结果将是引用
decltype((i)) d; // 错误, d是int&, 必须初始化
```

> 切记: `decltype((variable))`永远是引用, 而`decltype(variable)`结果只有当`variable`本身就是引用时才是引用



### 自定义数据结构

#### 类的数据成员

**数据成员**定义了类对象的具体内容, 每个对象都有一份数据成员copy, , 修改一个成员不会影响其余的成员

新标准规定, 可以为数据成员提供一个**类内初始化值**, 创建对象时, 类内初始化值将用于初始化值用于初始化数据成员. 没有初始化的成员将被默认初始化.



### 编写自己的头文件

类一般都不定义在函数体内, 挡在函数体外部定义类的时候, 在各个指定的源文件中可能只有一处该类的定义. 而且, 如果要在不同的文件中使用同一个类, 类的定义就必须保持一致.

头文件通常包含那些只能被定义一次的实体, 如类, `const`和`constexpr`变量



### 预处理器概念

确保头文件多次包含仍能安全工作的常用奇数时**预处理器**, 由`C++`语言从`C`语言继承而来, 一般采用`#ifndef`和`#define`以及`#endif`来防止头文件重复包含



## 字符串, 向量和数组



### 命名空间的`using`声明

我们用到的库函数基本都属于命名空间`std`, 作用域操作符`::`的含义时: 编译器应该从操作符左侧名字所示的作用域中寻找右侧那个名字, 但是**`using`声明**会将之边的简单. 

```c++
using namespace::name; // 可以直接访问命名空间的名字
```



#### 每个名字都需要独立的`using`声明

#### 头文件不应该包含`using`声明

如果头文件里有某个`using`声明, 那么每个使用了该头文件就会有这个声明. 对应某些程序, 可能会产生冲突.



### 标准库类型`string`

#### 常规操作

* 定义和初始化

  ```c++
  string str(10, 'c') // 表示10个c
  ```

* `=`表示拷贝初始化, 把等号右侧的初始值直接拷贝到左边, 实际上是先创建一个临时对象

* 如果不使用等号, 那么执行的时候**直接初始化**. 效率更高

* `getline()`作为`string`的输入流函数, 自动忽略空行, 也就是按行输入, 直到遇到换行符为止, 因此不包含`空行`

* `cin`按单词输入, 会自动忽略空行和空格

* `while(cin >> str)`可以用作不定数目的输入

* `string::size_type`表示长度的尺寸, 这里允许我们使用`auto`进行自动推断

* 处理`string`对象中的字符, 采用头文件中的`cctype`头文件定义标准库函数处理

* 处理每个字符, 采用基于范围的`for`循环

  ```c++
  for (dec: expr)
      statement
  ```

  使用范围`for`循环改变字符串中的字符, 可以把循环变量改变曾引用的格式, 这样就可以改变循环中的值, 转换为大写

### 标准库`vector`

表示对象的集合, 其中所有对象的类型都相同, 索引用于访问对象, 也称为**vector**, `C++`既有类模板, 也有函数模板, `vector`是一个类模板. 编译器根据模板创建类或者函数的过程称为**实例化**                      

#### 基本操作

* 定义和初始化操作

  ```c++
  // 只说明我没有见过的
  vector<T> v1;
  vector<T> v2(v1); // 直接初始化
  vector<T> v3(n, val); // 包含n个val
  vector<T> v4(n); // 包含n各个执行了初始化的对象
  vector<T> v5{a, b, c}; // 显式初始化赋值, 称为列表初始化
  ```

  `C++`提供了多种初始化方式, 第一个是拷贝初始化, 其次还有类内初始化,只能使用拷贝初始胡和花括号的形式, 以及列表初始化

  > 列表初始化会兼容()初始化

* 动态`push_back`效率更高

* 无法采用下标方式添加元素



### 迭代器介绍

迭代器提供了对象的间接访问, 有效的迭代器或者指向或者指向某个元素, 或者指向容器中尾元素的下一个位置, 其它所有情况都属于无效.

#### 使用迭代器

`begin`指向第一个元素的迭代器, `end`负责返回**尾元素的下一个位置**的迭代器, 也就是说该迭代器指示的容器的本不存在的**尾后**

##### 迭代器运算符

采用`==`和`!=`来比较两个合法迭代器相等

| `*iter` 所指元素的引用       |
| ---------------------------- |
| `iter->mem` 解引用并获取成员 |
| `++iter`指向下一个元素       |
| `--iter`指向上一个元素       |
| `==` 和`!=`判断相等          |

#### 迭代器类型

`vector<T>::iterator it`可以读写的迭代器, `vector<T>::const_iterator`只读元素



##### `begin`和`end`

返回类型有对象是否为常量决定, 如果为常量就返回只读, 否则返回普通的, 后来添加的`cbegin`和`cend`一定返回的是`const`类型



> 切记: 但凡是使用了迭代器的循环体, 都不要向迭代器所属的容器添加元素, 因为动态增长会是迭代器失效

##### 迭代器的算术运算

一直支持这种迭代器运算的的序列一般为顺序序列.



### 数组

数组也是存放类型相同的对象的容器, 但是这些对象需要通过位置访问, 数组的大小确定不变, 无法向其中增加元素, 性能比较好

> 数组的维度必须是一个常量表达式, 即`constxpr`类型

**这个部分由于和`C`过于类似, 所以不再细谈**

#### 标准库中的`begin`和`end`

新标准引入了`begin()`和`end()`函数, 一个返回组数的首元素地址, 另一个返回尾后元素地址



### `C`-style字符串

用法和`C`相同, 不再一一进行解释



### 多维数组

实际上是数组的数组, 阅读时由内向外推导





## 表达式

### 基础

#### 基本概念

基本使用和`C++`一样, 整型提升, 运算符结合顺序和结合性都是已经定义好的.

##### 左值和右值

基本概念是左值可以出现在赋值运算的左边, 右值可以出现在赋值运算的右边

**标准理解: 左值是指在内存中存在实际位置的对象, 可以理解成对于这个对象可以进行取地址运算,所有非左值都是右值.**

当一个对象被用作右值的时候, 采用的是对象中的值, 当对象被用作左值的时候, 用的是对象的身份(在内存中的位置), 当对象被用作左值的时候， 用的是对象的身份.

下面是几种常用的左值:

* 赋值运算符需要一个(非常量左值)作为其左侧运算对象, 得到的结果也仍然是一个左值
* **取地址运算符作用于一个左值运算对象, 返回一个指向该运算对象的指针, 指针是一个右值**
* 内置解引用运算符, 下标运算符, 迭代器解引用运算符的求值结果都是左值
* 内置类型和迭代器类型的递增递减运算符都作用域左值对象, 前置版本所得的结果也是左值

尤其使用关键字`decltype`的时候, 如果表达式所求值结果是左值, 那么关键字作用时得到一个引用类型

```c++
int i = 0;
int *p = &i;
decltype(*p) m = i; // 实际上会产生引用类型
decltype(&p) c; // 由于取地址运算符产生右值, 所以c是int**
```

#### 优先级和结合律

基本上和`C`的没有什么大不同, 求值顺序一般是未定义的

#### 求值顺序

`C++11`新标准规定商一律向0取整.



### 赋值运算符

`C++`新标准允许使用花括号括起来的初始化列表作为赋值语句的右侧运算对象, 对于`vector`也照样适用.

##### 赋值运算符的优先级较低

优先级`[] () . ->`是最高优先级, 其次是单目运算符, `++ *`

##### 前置版本的递增运算符效率要更高一点, 并且更符合变成规范

一种很重要的省略, `*p++`, 由于结合性的原因, 实际上等同于`*(p++)`

`++`后置是先运算, 再加; `++`前置是先加, 再运算



### 成员访问运算符

`.`和`->`运算符, 箭头运算符作用一个指针类型的运算对象, 结果是一个左值. 点运算分成两种情况, 如果成员所属的对象是左值, 那么结果是左值; 反之如果成员所属的对象是右值, 那么结果也是右值



### `sizeof`运算符

返回一个类型所占字节数, `sizeof`可以作用无效指针的解引用, 因为它不计算值, 它只进行推断



### 逗号运算符

最后一个表达式作为返回值



### 类型转换

#### 隐式类型转换

和`C`语言基本一致, 因此不再赘述

#### 显式类型转换

##### 命名的强制类型转换

格式如下:

```cpp
cast-name<type>(expression);
```

其中`type`是转换的目标类型而`expression`是要转换的值, 如果`type`是引用类型, 则结果是左值类型. `cast-name`是`static_cast`, `dynamic_cast`和`const_cast`和`reinterpret_cast`中的一种.

* `static_cast`任何具有明确定义的类型转换, 只要不包含底层`const`, 都可以使用`static_cast`, 在把一个较大的算术类型赋值给较小的类型的时候, 非常有用, 此时强制类型转换告诉编译器我不在乎可能会丢失的精度

* `const_cast`只能改变运算对象的底层`const`

  ```c++
  const char *pc;
  char *p = const_cast<char*>(pc); // 将底层const转换为普通
  ```

  我们称之为去掉`const`性质, 一旦我们去掉了`const`性质, 也仅有`const_cast`可以改变常量属性. 常常用于有函数重载的上文文当中.

* `reinterpret_cast`

  通常为运算对象的位模式提供较低层次上的重新解释, 很危险, 一般用在底层的罗基范以上



### 运算符优先级

| ::     |
| ------ |
| .      |
| ->     |
| []     |
| ()     |
| ++     |
| --     |
| typeid |



## 语句

### 简单语句

略

#### 范围`for`语句

```c++
for (decl: exp)
    statement;
```

`exp`必须要实现迭代器



### `try`语句块和异常处理

异常是指存在运行时的反常行为, 处理一行行为时所有系统设计最难的一部分. 异常处理机制为程序中**异常检测**和**异常处理**这两部分的协作提供支持, `C++`处理包括:

* `throw`表达式

  异常检测部分使用`throw`表达式来表示它遇到了无法处理的问题, 我们说`throw`**引发**了异常

* `try`语句块

  异常处理部分使用`try`语句处理异常, 以`try`关键字开始, 并以一个或者多个`catch`语句结束, `try`语句块中代码抛出的异常会被`catch`子句处理, 也被称为异常独立代码

* 一套**异常类(exception class)**, 用于在`throw`表达式和相关`catch`子句之间传递异常的具体信息

#### `throw`表达式

程序异常检测部分使用`throw`表达式引发一个异常. `throw`表达式包含关键字`throw`和紧随其后的一个表达式, 其中表达式的类型就是抛出的异常类型. `throw`表达式后面通常紧跟一个分号, 从而构成一条表达式

```c++
if (item1.isbn() != item2.isbn())
    throw runtime_error("Data must refer to the same ISBN");
// 代码会抛出异常终止当前函数, 并把控制权转移给处理该异常的代码
```

#### `try`语句块

```c++
try {
    statement
} catch (exception) {
    
} catch () {
    statement
}
```

`try`语句一开始关键字为`try`, 随后紧跟一个块. `catch`子句包括三部分: 关键字`catch`, 括号内的对象声明(称为**异常声明**)以及一个块. 当选中某个`catch`子句处理异常之后, 执行对应的块, `catch`一旦完成, 程序跳转`try`语句块最后一个`catch`之后的语句继续执行

##### 编写处理代码

```c++
try {
    if () throw exception(what);
} catch (exception e) {
    cerr << e.what() << endl;
}
```

`try`语句块对应一个`catch`子句负责处理某个类型的异常. `what`是`stdexception`的一个成员函数, 返回`c-style`字符串

##### 函数在寻找处理代码的过程中退出

可能存在多个`try`语句嵌套, 寻找处理代码的过程与函数调用链刚好相反. 当异常被抛出时, 首先搜索抛出该异常的函数, 如果还没有找到匹配的`catch`, 终止该函数, 然后再调用该函数的函数中继续寻找. 以此类推, 逐层退出, 如果最后还时没能找到任何匹配的`catch`子句, 程序转到名为`terninate`的标准库函数, 导致非正常退出.



#### 标准异常

* `exception`头文件定义了最通用的异常类`exception`, 只报告异常的发生, 不提供额外对的信息
* `stdexception`头文件定义了常用的异常类型
* `new`头文件`bad_alloc`异常类型
* `type_info`头文件定义了`bad_cast`异常类型

| `stdexcept`异常                                         |
| ------------------------------------------------------- |
| `exception`最常见问题                                   |
| `runtime_error`运行时错误                               |
| `range_error`运行时错误, 生成结果超出了有意义的值域范围 |
| `overflow_error`计算上溢出                              |
| `underflow_error`计算下溢出                             |
| `logic_error`程序逻辑错误                               |
| `domain_error`参数对应的结果值不存在                    |
| `invalid_argument`无效参数                              |
| `length_error`试图创建                                  |
| `out_of_range`超出一个超出有效范围的值                  |



## 函数

### 函数基础

一个典型的函数包括: 

* 返回类型
* 函数名字
* 形参列表
* 函数体

我们通过调用运算符或者说是括号运算符来执行函数.

##### 形参和实参

实参是形参的初始值

#### 局部对象

对象有生命周期

* 名字的作用域是程序文本的一部分, 名字在其中可见
* 对象的生命周期是程序执行过程中该对象存在的一段时间

形参和函数体内部定义的变量统称为**局部变量**, 同时局部变量还会隐藏外层作用域中同名的其他声明, 我们称之为**局部优先原则**

##### 自动对现象

对于普通的局部变量来讲, 我们把只存在于块执行期间的对象称为**自动对象**

##### 局部静态变量

将局部变量定义为`static`类型, 声明周期为整个程序运行期间, 统计函数自己被调用多少次, 如果局部变量没有显式初始值, 它将执行值初始化, 一般为`0`.



#### 函数声明

函数只能定义一次, 但是可以声明多次, 两者唯一区别是函数声明无需函数体, 函数声明也成为函数原型

##### 在头文件中进行函数声明

一般建议变量在头文件中进行声明, 在源文件中进行定义



#### 分离式编译



### 参数传递

按值传递和按引用传递

#### 按值传递

也就是额外拷贝副本

##### 指针形参

形参和实参不是同一个指针(位置不再同一个地方), 但是指向的值都是同一个.



#### 按引用传参

##### 使用引用避免拷贝

`IO`等类型不支持拷贝操作, 并且大的类型拷贝很低效. 当某种类型不支持`copy`操作的时候, 函数只能通过引用形参访问该类型的对象

> 如果函数无需改变引用形参的值, 最好将之声明为常量引用

##### 使用引用形参返回额外信息

也就是说我们的引用可以有`out`方向

#### `const`形参和实参

当实参初始化形参时会忽略掉顶层`const`, 也就是形参的顶层`const`会被忽略

```c++
int f(const int i) {
    return i;
}

int f(int i) {
    return i;
}

// 这种行为是错误的, 因为顶层const会被忽略, f(0)时编译器无法决定应该调用哪个函数
```

##### 指针或引用形参与`const`

这种和引用与指针的赋值方式具有相同的作用

##### 尽量使用常量引用

只要不改变其中的值都应该使用常量引用

#### 数组形参

实际上传递的是指针

##### 数组引用形参

```c++
void print(int (&arr)[10]) {
    for (auto elem : arr)
        cout << elem << endl;
}
// 数组引用可以保留数组的信息
```

#### 含有可变形参的函数

为了能编写处理不同数量实参的函数, `C++11`新标准提供了两种主要方法:

* 如果所有的实参类型相同, 可以传递一个名为`initialize_list`的标准库类型
* 如果实参类型不同, 可以编写一种特殊函数, 也就是所谓的可变参数模板

##### `initializer_list`形参

函数全部实参数量未知但是类型全部相同, 可以使用. `initializer_list<T> ls`对象中的元素永远是常量值, 无法修改

> 实际上本质就是一个`vector`, 初始化的方式采用列表初始化, 然后这个返回的对象是`const`, 因此无法修改返回的对象, `auto`可以自动类型推断



### 返回类型和`return`语句

返回值的方式和初始化变量或形参的方式完全一样: 返回值用于初始化调用点的一个临时值, 该临时量就是函数调用的结果.

如果函数返回引用, 则该引用仅是它所属对象的一个别名, 举个例子:

```c++
const string & shortString(const string &s1, const string &s2) {
    return s1.size() <= s2.size() ? s1 : s2;
}
```

实际上本质还是传递给一个临时变量, 然后临时变量再赋给断点处.

##### 不要返回局部对象的引用或指针

因为局部变量会被释放

##### 返回类类型的函数和调用运算符

优先从左到右结合

##### 引用返回左值

函数的返回类型决堤的那个函数调用时否时是左值. 调用一个返回引用的函数得到左值, 其它类型得到右值, 如果返回一个常量引用同样不能进行赋值操作.

##### 列表初始化返回值

`C++`标准规定, 函数可以返回花括号包围的值的列表. 类似于其它返回结果, 这个列表也用来表示函数返回的临时变量初始化. 可以返回空列表, 如果函数返回内置类型, 则花括号包围的列表最多包含一个值. 如果返回的是类类型, 由类本身定义初始值如何使用.

> 一般针对`vector`等可以列表初始化的类型

#### 返回数组指针

##### 声明一个返回数组指针的函数

```c++
int (*func(int i))[10]; // func是一个函数, 返回一个指针, 指针指向一个10个元素的int型数组
```

##### 使用尾置返回类型

`C++11`中可以简化上述`func`声明方式, 采用**尾置返回类型**(trailing return type). 任何函数定义都能使用尾置返回, 这种形式对应返回类型比较复杂的函数最有效, 比如返回类型是数组的指针, 或者数组的引用.

```c++
auto func(int i) -> int (*)[10];
// 前缀用auto代替, 将真正类型放置在->之后
```

##### 使用`decltype`

还有一种情况, 如果我们知道函数返回的指针将指向哪个数组, 就可以使用`decltype`关键字声明返回类型

```c++
int odd[] = {1, 3, 5, 7, 9};
int even[] = {0, 2, 4, 6, 8};
decltype(odd) *arrPtr(int i) {
    return (i % 2) ? &odd : &e
}
```



### 函数重载

如果同一个作用域内的几个函数名字相同, 但是形参列表不同, 我们称之为重载函数.

> `main`函数不能重载

##### 定义重载函数

仅有返回类型不同的函数不是重载, 编译器会报错.

##### 判断两个形参的类型是否相异

形参名会省略, 别名会被检测出来

##### 重载和`const`形参

顶层`const`不影响传入函数的对象. 一个拥有顶层`const`的形参和一个没有顶层`const`的形参无法区分

```c++
int f(const int i);
int f(int);

int f(int const *p);
int f(int *p);

// 上面两种函数无法区分
```

另一方面如果形参时某种类型的指针和引用, 则通过区分其是指向常量对象还是非常量对象可以实现重载, 此时`const`是底层的.

```c++
int f(const int &i);
int f(int &i);

int f(int *p);
int f(const int *p);
```

* 一种无法区分, 一种可区分:
  1. 无法区分: 顶层`const`和无顶层`const`
  2. 可区分: 底层`const`引用和普通引用
* 如果传递非常量对象, 编译器优先选择非常量版本



##### `const_cast`和重载

`const_cast`在重载函数中效果最好

```c++
const string& shorter(const string &s1, const string &s2) {
    return s1.size() > s2.size() ? s2 : s1;
}

string & shorter(string & s1, string & s2) {
    auto & r = shorter(const_cast<const string&>(s1), const_cast<const string&>(s2));
    return const_cast<string&>(r);
}
```



##### 调用重载的函数

函数匹配指的是一个过程, 把函数调用和函数重载关联起来叫做**重载确定**. 



#### 重载与作用域

一般来说, 函数声明放在一个局部作用域内不是一个明智的选择.

内层作用域中的声明名字, 将隐藏外层作用域中声明的同名实体, 在不同的作用域无法重载函数名.

### 特殊语言特性

#### 默认实参

把反复出现的值称为函数的默认实参, 调用时可以包含该实参也可以省略该实参

##### 使用默认实参调用函数

如果想要使用默认实参, 只需要在调用时省略该实参即可, 调用时按照位置解析. 省略的时候只能省略尾部的实参.

##### 默认实参声明

对于函数声明来讲, 通常习惯时将之放在头文件中, 并且一个函数只声明一次. 我们不能修改一个已经存在的默认值

> 给定的作用域中的一个形参只能被赋予一次默认实参, 也就是说后续的声明只能为那些之前还没有默认值的形参添加默认实参, 而且该形参右侧的所有形参都必须有默认值

##### 默认实参初始值

局部变量不能作为默认实参



#### 内联函数和`constexpr`函数

一般函数调用的过程会进行保留寄存器, 返回时恢复寄存器, 拷贝实参等耗时操作.

##### 内联函数可以避免函数调用的开销

将函数指定为内联函数, 就是将函数在调用点原地展开, 我们只需呀在函数的返回类型前加上关键字`inline`用来表示内联

> 内联只是向编译器发出的请求, 编译器可以进行忽略. 内联机制一般适合规模小, 流程直接, 调用频繁的函数



##### `constexpr`函数

`constexpr`函数是指能用于常量表达式的函数, 定义函数的方式与其它函数类似, 不过需要遵循几项约定:

* 函数返回类型以及所有的形参类型都必须时字面值类型
* 函数体中必须只有一条`return`语句

`constexpr`函数被隐式的指定为内联

> `constexpr`函数的返回值不一定是常量表达式, 这和我们传入参数的类型有关系, 只有传入常量或者表达式, 结果才会是常量表达式, 反之则不然



##### 把内联函数和`constexpr`函数放在头文件内

内联函数可以在程序中多次定义, 但是多个定义必须完全一致, 通常定义在头文件中.



#### 调试帮助

`C++`程序员有时想要采用头文件保护的技术， 以便有选择地执行调试代码



##### `assert`预处理宏

`assert`是一种**预处理宏**, 也就是编译器会在编译过程原地展开为一段代码

```c++
assert(expr)
```

首先对`expr`求值, 如果表达为假, `assert`输出信息并终止程序执行, 为真的话程序什么也不做.

`assert`宏定义在`cassert`头文件中, 预处理名字由预处理器进行管理而非编译器. 因此我们可以直接使用名字而无需提供`using`声明, 也就是说直接使用`assert`



##### `NDEBUG`

`assert`的行为依赖于一个名为`NDEBUG`的预处理变量状态, 如果定义了`NDEBUG`, 那么`assert`什么也不做, 默认状态下没有定义, 因此将会执行检查

我们可以使用一个`#define`语句定义`NDEBUG`, 从而关闭调试状态, 定义`NDEBUG`能避免检查各种条件所需的运行时开销, 当然此时根本不会执行运行时检查. 因此`assert`应该仅用于验证哪些确实不可能发生的事情. 我们可以把`assert`当成调试程序的一种辅助手段, 但是不能替代它成为真正的运行时逻辑检查, 也不能替代程序本身应该检查的错误.

> 真正的运行时逻辑检查还是应该自己检查, 并且采用异常的处理机制



##### 一些常用的调试定义

| `__func__` | 存放当前函数名的字符串字面值   |
| ---------- | ------------------------------ |
| `__LINE__` | 存放当前行号整型字面值         |
| `__TIME__` | 存放文件编译时间的字符串字面值 |
| `__DATE__` | 存放文件编译日期的字符串面值   |
| `__FILE__` | 存放当前文件名的字符串面值     |



### 函数匹配

##### 确定候选函数和可行函数

函数匹配过程为:

1. 选定本次调用对应的重载函数集, 集合中的函数称为**候选函数**. 候选函数具备两个特征: 一是与被调用的函数同名, 二是声明在调用点可见
2. 考察本次调用提供的实参, 然后从候选函数中选出能被这组实参调用的函数, 这些新选出的函数称为可行函数. 可行函数具备两个特征, 一是其形参数量与本次调用提供的实参数量相等(如果填了默认参数而满足调用关系的也计算在内), 二是每个实参的类型与对应的形参类型相同, 或者能转化为形参的类型.

##### 寻找最佳匹配(如果有的话)

实参类型和形参类型越接近, 它的匹配越好

##### 含有多个形参的函数匹配

当实参的数量有两个或者更多的时候

#### 实参类型转换

为了确定最佳匹配, 编译器将实参类型到形参的转换划分等级:

1. 精确匹配
   * 实参类型和形参类型相同
   * 实参从数组类型或函数类型转换成对应的指针类型
   * 向实参添加顶层`const`或者删除顶层`const`
2. 通过`const`转换实现匹配
3. 通过类型提升实现匹配
4. 通过算术类型转换或者指针转化
5. 通过类类型转换实现的匹配

> 所有算术转化的优先级都是相同的



### 函数指针

函数指针指向的是函数而非对象, 函数的类型由它的返回类型, 形参共同决定, 与函数名无关

##### 使用函数指针

当把函数名作为值使用的时候, 函数自动的转化为指针

```C++
bool lengthCmp(const string &, const string &);

bool (*f)(const string &, const string &);

auto pf = lengthCmp;
auto pf = &lengthCmp;
```

##### 函数指针作为形参

```c++
typedef bool Func(const string &, const string &);
typedef decltype(lengthCmp) Func;

typedef bool (*Func)(const string &, const string &);
typedef decltype(lengthCmp)* Func;
// 注意decltype只返回函数类型, 必须加上*才能转化为指针
```

##### 返回指向函数的指针

```c++
using F = int(int*, int); // 函数类型
using PF = int(*)(int*, int); // 函数指针
```

所以写的时候要么采用尾置返回类型和`decltype`

> `delctype`需要注意的是我们需要显式的添加*来表示指针



## 类

> 类的一些作用, 含义等不再赘述, 都不知道看多少遍了

##### `this`指向对象本身

##### `const`成员函数

函数之后紧跟`const`表示`this`是个常量指针, 也就是无法修改其内容. 这种函数被称为常量成员函数.

> 常量对象, 常量对象引用或指针都只能调用常量成员函数

##### 类作用域和成员函数

由于编译过程分两步处理类:

* 首先编译成员声明
* 成员函数

因此成员函数可以任意使用类中的其它成员而无须在意出现次序

##### 在类的外部定义成员函数

##### 定义一个返回`this`对象的函数

一般来讲当我们需要返回一个左值的时候我们会采用`this`, 那么返回类型应该采用引用的形式.

#### 定义类相关的非成员函数

通常把函数的声明和定义分开, 一般来说非成员函数是类接口的组成部分, 这些函数声明应该和类在同一个头文件中

`IO`类属于不可拷贝的的类型, 因此只能通过引用来传递它, 并且由于读取和写入操作会改变流的内容, 所以两个参数接受的都是普通引用, 而非常量引用.



#### 构造函数

只要类的对象被创建, 就会执行构造函数.

构造函数无法被声明为`const`, 当我们创建一个`const`对象时, 直到构造函数完成初始化过程, 对象才算真正取得了常量属性

##### 默认构造函数

编译器在没有构造函数的情况下会自动生成一个空的, 没有参数的构造函数.

但是默认构造函数并不总是可靠的, 有些情况下是无法创建默认构造函数

##### `= default`的含义

在`C++11`新标准中, 如果我们需要默认行为, 那么可以在参数列表后面写上`= default`来要求编译器生成构造函数, 这个声明即可以出现在类的外部, 也可以出现类的内部. **一般前提是我们执行类内初始化**

```c++
class T {
    int i = 0;
    int j = 0; // 类内初始化
    T() = default; // 默认行为的构造函数
};
```



##### 构造函数初始化列表

负责为新创建的对象的一个或几个数据成员赋初值. 构造函数初始值是成员名字的一个列表, 每个名字后面紧跟括号括起来成员初始值, 不同成员通过逗号分割.

通常来说, 构造函数采用类内初始值不失为一种好的选择, 因为只要这样的初始值存在, 我们就能确保为成员赋予了一个正确的值.

```c++
class T {
    string name = "";
    int i = 0;
    T() = default;
    T(const string & _s, int _i): name(s), i(_i) {}
};
```

##### 在类的外部定义构造函数

构造函数没有返回值



#### 拷贝, 赋值和析构

除了初始化, 类还需要控制拷贝, 赋值, 和销毁时对象发生的行为. 对象会在下列情况被拷贝(不全面):

* 初始化变量
* 以值的方式传递或返回一个对象

赋值运算符发生对象的赋值, 当对象不再存在的时候执行销毁动作.

> 如果我们不主动定义, 编译器会自动为我们生成默认版本

##### 某些类不能依赖合成版本

管理动态内存的时候无法依赖上述操作的合成版本.



### 访问控制和封装

**访问说明符**加强类的封装性:

* `public`说明成员对外部可见, 一般定义类的接口
* `private`说明成员对外部不可见, 一般定义类的数据成员

作为接口构造函数一般为`public`, 数据成员和实现一般`private`, 一个类可以包含0个或者多个访问说明符



##### 采用`class`和`struct`

`struct`默认权限是`public`, `class`默认权限是`private`



#### 友元

类允许其他类或者函数访问非公共有成员, 方法是令其它类或者函数称为它的**友元**, 如果类想要把一个函数作为它的**友元**, 只需要添加一条`friend`关键字开始的函数声明. **这个声明我们需要写在类中**, 实现可以写在函数外, 注意友元并非是类的成员.

> 一般最好在类的结束和开始集中声明友元, 不受类的访问权限控制

##### 友元的声明

友元的声明只是指定了访问权限, 而非一个通常意义上的函数声明. 如果我们希望类的用户能够调用某个友元函数, 那么我们就必须在友元声明之外再专门对函数进行一次声明.

为了使友元对类的用户可见, 我们通过把友元的声明与类本身放置在同一个头文件中, 为此我们需要单独再次提供声明.

> 也就是说我们在类里面声明的友元只是一种权限说明, 我是你的朋友. 真正的你还需要自己来声明和定义这个函数



### 类的其它特性

#### 类成员再探

一般来说类中的别名我们在`public`区进行声明, 这样使用户可见, **并且定义类型的成员必须先定义后使用**

```c++
class T
{
public:
    typedef ;
    using;
}
```

##### 令成员作为内联函数

一般类内部的成员函数默认内联, 你也可以显式声明`inline`, 当然也可以在类外部声明`inline`

##### 重载成员函数

和一般重载没有显著区别

##### 可变数据成员

有时我们希望能修改类的某个成员数据, 即使是在一个`const`成员内, 我们可以在变量声明中加入`mutable`关键字做到这一点. **可变数据成员**永远不会是`const`, 因此一个`const`成员函数可以改变一个`mutable`值

```c++
class T {
    mutable int i; // 指定i在const成员中也可改变
}
```

> 我所见过使用这种方式的出现在优化链表, `set_position`函数

##### 类数据成员的初始值

最好的方式是新标准中的类内初始化. 类内初始值必须采用`=`或者`{}`方式进行初始化



#### 返回`*this`的成员函数

采用返回左值的`*this`成员函数, 可以改变初始值的状态, 并进行连续操作.

```c++
T& returnThis() {
    return *this;
}
```



##### 从`const`成员函数返回`*this`

> 一个`const`成员函数如果以引用的方式返回`*this`, 那么返回类型将是常量引用



##### 基于`const`的重载

通过区分成员函数是否是`const`, 我们可以对其进行重载, 这和之前的顶层底层`const`的说法一致.

因此可见非常量对象优先调用非`const`函数, 而`const`对象优先调用`const`函数. 对象是否为`const`决定了应该调用那个版本.



#### 类类型

每个类都定义了唯一的类型, 对于两个类来说, 即使它们的成员完全一样, 这两个类也是不同的类型.

##### 类的声明

就像可以把函数声明和定义分离开一样, 我们也能仅声明类而暂时不定义它.

```c++
class T;
```

这种声明称为向前声明, 它向程序引入了名字, 并且指名了类型, 如果还没有定义, 那么它是一个不完全类. 允许这样的类产生指针和引用, 但是不允许类产生自己的类型.



#### 友元再谈

##### 类之间的友元关系

```c++
class T {
    friend class M;
};
```

如果一个类指定了友元类, 则友元类的成员函数可以访问此类包括非公有成员在内的所有成员.

> 需要注意, 友元关系不存在传递关系, 朋友的朋友不一定使朋友

##### 令成员函数作为友元

```c++
class T {
    friend void M::foo(parameter);
}
```

除了令整个类作为友元, 也可以指定为指定函数作为友元, 要想让某个成员函数作为友元, 我们必须要仔细组织程序的结构以满足声明和定义的彼此依赖关系

1. 首先定义友元函数所在的类, 其中声明友元函数, 但是不能定义
2. 定义要包含的友元函数的类, 声明友元成员函数
3. 最后再定义友元函数

##### 友元声明和作用域

> 友元声明只是影响权限访问控制, 并非真正意义上的声明, 因此声明还需要额外进行.



### 类的作用域

#### 名字查找和类的作用域

**名字查找**寻找与所用名字最匹配的声明的过程:

* 首先, 在名字所在的块中去寻找声明语句, 只考虑再名字使用之前声明的
* 如果没有找到, 继续外层查找
* 如果最终没有找到, 报错

对于类来说, 上述查找规则有所区别:

* 首先编译成员声明
* 直到类全部可见后编译函数体

> 编译器处理完类中的全部声明后才会处理成员函数定义

##### 用于类成员声明的名字查找

这两阶段的处理方式只适用于成员函数中使用的名字. 声明中使用的名字, 包括返回值类型, 或者参数列表中使用的名字, 都必须在使用前确保可见.

```c++
// 类型名, 别名必须要先出现
```

##### 特殊处理类型名

如果成员使用了外层作用域中的某个名字, 而该名字代表一种类型, 则类不能在之后重新定义该名字

```c++
typedef double Money;
class Account {
public:
    Money balance() { return bal; }
private:
    typedef double Money; // 错误, 无法重新定义
}
```

> 类型名的定义一般出现在类的开始处, 这样就能确保所有使用该类型的成员都出现在类名的定义之后



##### 成员定义中的普通块作用域的名字查找

成员函数中的名字查找按照如下方式解析:

* 首先在成员函数内查找该名字
* 如果成员函数内没找到, 到类内查找
* 如果内类没有则在作用域之前查找

##### 类作用域之后, 在外围的作用域中查找

如果我们希望使用外层作用域中的名字

```c++
::var; // 很不建议这样写;
```



### 构造函数再探

对于任何`C++`类来说, 构造函数都是最重要的组成部分

#### 构造函数初始化列表

**对对象成员来说, 如果没有在构造函数的初始值列表中显式的初始化成员, 则该成员将在构造函数体之前执行默认初始化.**

##### 构造函数的初始值有时必不可少

如果成员是`const`或者引用的化, 必须要将之初始化, 当成员属于某种类型, 并且该类型没有定义默认构造函数的时候, 也必须将这个成员初始化.

```c++
class ConstRef 
{
private:
    int i;
    const int ci;
    int &ri;
public:
    ConstRef(int ii);
};

ConstRef::ConstRef(int ii) {
    i = ii; // 正确
    ci = ii; // 错误, 无法被赋值
    ri = ii; // 错误, 五福初始化
}

ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(ii) {} // 正确

```

> Warning: 如果成员是`const`, 引用, 或者属于某种未提供默认构造函数的类类型, 我们必须通过构造函数初始值列表为这些成员提供初始值.
>
> 也就是说进行初始化的时候, 实际上首先首先看变量是否在初始化列表中(在初始化列表中的值不会执行默认初始化), 不在的话先执行默认初始化/类内初始化, 然后执行初始化列表, 最后才是函数体



> 建议使用构造函数初始值列表, 在很多类中初始化和赋值事关底层效率: 前者直接初始化数据成员, 后者则先初始化再赋值, 最后才执行函数体
>
> 除了效率之外, 一些数据成员必须初始化. 建议使用构造函数初始化列表



##### 成员初始化顺序

在构造函数初始值中华每个成员仅能出现一次. 构造函数初始值列表只说明用于初始化成员的值, 而不限定执行顺序.

**成员初始化顺序与他们在类中的定义出现顺序一致, 第一个成员先被初始化, 依次类推**



##### 默认实参和构造函数



#### 委托构造函数

新标准扩展了构造函数初始值的功能, 使得我们可以定义**委托构造函数delegating constructor**, 一个委托构造函数使用它所属类的其它构造函数执行自己的初始化过程, 或者说是它把自己的一些职责委托给了其它构造函数.

在委托构造函数中, 也有一个成员初始化列表和一个函数体, 在委托构造函数内, 成员初始值列表只有一个唯一的入口, 那就是类名本身, 参数列表必须和另外一个构造函数匹配.

> 执行顺序, 先执行委托函数及其函数体, 然后再执行本函数的函数体

#### 默认构造函数的作用

当对象被默认初始化或值初始化时自动执行默认构造函数, 默认初始化再以下情况发生:

* 再块作用域下不使用任何初始值定义一个非静态变量或者数组时
* 当类成员本身含有默认构造函数
* 当类成员没有再初始化列表中显式初始化

> 不多bb, 感觉没啥用



##### 使用默认构造函数

```c++
T a; // 默认初始化, 不要加括号
```



#### 隐式的类型转化

如果构造函数只接受一个实参, 则它实际上定义了转化为此类类型的隐式转化机制, 有时我们把这种构造函数称之为**转换构造函数**

##### 只允许一步转换

##### 类类型转换并不总是有效的

##### 抑制构造函数定义的隐式转换

我们可以将构造函数声明为`explicit`加以阻止, 这个关键字只对一个实参的构造函数有效, 并且只能在类内声明构造函数时使用, 在外部无须重复.

##### `explicit`构造函数只能用于直接初始化

发生隐式转换的一种情况是我们执行拷贝形式的初始化时

> 当我们采用`explicit`关键字声明构造函数的时候, 它将只能以直接初始化的形式使用, 而且编译器不会再自动转换过程中使用该构造函数



##### 为转换显式地使用构造函数

虽然不能隐式转换了, 但是我们可以显式转换.



#### 聚合类

**聚合类**允许可以直接访问其成员, 并且具有特殊地初始化语法形式, 聚合要求:

* 所有成员都是`public`
* 没有定义任何构造函数
* 没有类内初始化
* 没有基类, 也没有`virtual`函数

比如简单的`C struct`

我们可以提供一个花括号括起来表示成员初始化列表, 要注意顺序



#### 字面值常量类

某些类也是字面值类型, 字面值类型的类可能含有`constexpr`函数成员, 这样的成员必须符合`constexpr`函数的所有要求, 它们是隐式`const`

数据成员都是字面值类型的聚合类是字面值常量类. 如果一个类不是聚合类, 但是满足如下要求:

* 数据成员都是字面值类型
* 类必须至少含有一个`constexpr`构造函数
* 如果一个数成员含有类内初始化值, 则内置类型成员的初始值必须是常量表达式
* 类必须使用析构函数的默认定义, 该成员负责销毁类的对象           

`constexpr`构造函数必须要初始化所有成员数据, 初始值或者使用`constexpr`构造函数, 或者一条常量表达式, **意味着构造函数为空** 



### 类的静态成员

有的时候类需要它的一些成员与类本身直接相关, 而不是于类的各个对象保持关联.

##### 声明静态成员

我们通过在成员的声明之前加上关键字`static`使得其与类关联在一起, 和其他成员一样, 静态成员可以是`public`, 或者`protected`, 静态数据成员的类型可以是常量, 引用, 指针, 类等等.

类的静态成员存在于任何对象之外, 对象不包含任何与静态数据成员有关的数据. 类似的静态成员函数也不与任何对象`binding`在一起, 不包含`this`指针, 因此不能声明为`const`, 并且也不能在函数体内使用`this`指针

```c++
class T
{
public:
    static double insurance;
};
```

##### 使用类的静态成员

我们需要采用域运算符直接访问静态成员. 虽然静态成员不属于类的某个对象, 但是我们仍然可以使用类的对象, 引用或者指针来访问静态成员.

成员函数不用通过作用域运算符就能直接使用静态成员



##### 定义静态成员

我们既可以在类的外部也可以在内的内部定义静态成员函数, 当在类的外部定义静态成员时, 不能重复`static`关键字, 关键字只能出现在类的内部声明

因为静态数据成员不属于类的任何一个对象, 因此并不是在创建类的对象时时被定义的, 这意味着它们它们不是由类的构造函数初始化, 一般来说我们必须在类的外部定义并初始化每个静态成员.

```c++
T Class::member = something;
// 即使静态成员和函数都是私有的, 也能进行初始化
```

> 要想确保对象只定义一次, 最好的方法时把静态数据成员的定义和其它非内联函数的定义放在同一个文件中



##### 静态成员的类内初始化

通常情况下, 类的静态成员不应该在类的内部初始化. 然而, 我们可以为静态成员提供`const`整数类型的类内初始化.  不过要求静态成员必须时字面值常量类型的`constexpr`. 初始值必须是常量类型, 因为这些成员本身就是常量表达式

```c++
class T
{
private:
    static constexpr T var = exp; // 常量表达式, 适合编译器阶段的常量
}
```

> 如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况, 则一个初始化的`const`或者`constexpr static`不需要分别定义. 如果我们将它用于不能替换的场景中, 则该成员必须有一条定义语句.

> 即使一个`const static`数据成员在类内部初始化了, 通常情况下也应该在类的外部定义以下该成员.???



##### 静态成员能用于某些场合, 而普通成员不能

静态数据类型可以是不完全类型. 特别的, 静态数据成员的类型可以就是它所属的类类型, 而非静态数据成员则受到限制, 只能声明成它所属的指针或引用.

```c++
class Bar
{
public:
    //
private:
    static Bar mem1; // 正确
    Bar *meme2; // 正确
    Bar mem3; // 错误
}
```

另一个区别时静态成员可以作为默认实参

```c++
class Screen
{
public:
    Screen& clear(char = bkground);
private:
    static const char bkground;
}
```

非静态数据成员不能作为默认实参, 因为本身是对象的一部分.



## `C++`标准库

### `IO`类

| `iostream` | `istream`, `ostream`读写数据操作等等, 还有`w`的宽字符 |
| ---------- | ----------------------------------------------------- |
| `fstream`  | `ifstream`, `oftream`读写文件操作, `w`宽字符          |
| `sstream`  | `stringstream`, 读写`string`, 有`w`类型               |

为了支持使用宽字符, 标准库定义了`wchar_t`类型的数据, 这些都以`w`开头, 如`wcin`, `wcout`, `wcerr`等等

由于库之间采用继承的机制, 因此使用起来没有差别.



#### `IO`对象无拷贝或者赋值

```c++
ofstream o1, o2;
o1 = o2; // 无法赋值
ofstream p(o1); // 无法拷贝
// 因此一般采用引用的方式返回流对象, 并且不能设置为const, 因为流状态会改变;
```



#### 条件状态

`IO`操作一个与生俱来的问题是发生错误, 一些错误是可恢复, 而其它错误则发生系统深处, 超出了程序可以修复的范围, `IO`类定义一些函数, 可以访问和操纵流的**条件状态**.

| `strm::iostate`   | 机器相关的类型, 提供了表达条件状态的完整功能 |
| ----------------- | -------------------------------------------- |
| `strm::badbit`    | 指出流已经崩溃                               |
| `strm::failbit`   | 指出`IO`操作失败                             |
| `strm::eofbit`    | 指出流达到了文件结束                         |
| `strm::goodbit`   | 指出流未处于错误状态                         |
| `eof`             |                                              |
| `fail`            |                                              |
| `bad`             |                                              |
| `good`            |                                              |
| `clear`           | 将流的所有状态复位                           |
| `clear(flags)`    |                                              |
| `setstate(flags)` |                                              |
| `rdstate()`       |                                              |

> 先暂时放一放， 等回来再看



## 顺序容器

先掠过



## 泛型算法

先掠过



#### `lambda`表达式



##### 介绍`labmbda`

向任何算法传递**可调用对象**, 对于一个对象或者表达式, 如果可以对其使用调用运算符, 则称它为可调用的, 实现方式如下

* 函数
* 函数指针
* 重载`()`运算符
* `lambda`表达式

一个`lambda`可以表示一个可调用代码单元, 可以理解成未命名的内联函数, 具有返回类型, 参数列表, 函数体. 但是和普通函数不同, `lambda`可能定义在函数内部, 具有如下形式:

```c++
[capture list](parameter list) -> return type { body } // 采用尾置返回类型
```

其中捕获列表是一个`lambda`所在函数中定义的局部变量的列表(通常为空)

我们可以忽略参数列表和返回类型, 但是捕获列表和函数体不能省:

```c++
auto f = [] { return 42; }
cout << f() << endl;
```

在`lambda`中忽略括号和参数列表等价于指定一个空参数列表, 如此一来, 当调用`f`时, 参数列表为空, 如果忽略返回类型, `lambda`根据函数体中的代码推断出返回类型

> 如果`lambda`函数体包含任何单一`return`语句之外的内容, 且未指定返回类型, 则返回`void`



##### 向`lambda`传递参数

实参形参匹配, 但是不允许**默认参数**

```c++
[](const string & s1, const string & s2)
{    return a.size() < b.size() ;       };
```

然后就可以直接进行调用



##### 使用捕获列表

`lambda`可以出现在函数中指定要使用的局部变量, 但是必须要明确指出, 捕获列表指引`lambda`在其内部包含及局部变量信息

```c++
	[sz](const string &a)
{	return a.size() >= sz;	};
// 必须捕获之后才能进行使用
```



##### `for_each`算法

算法接受一个可调用对象, 并对输入序列中 的每个元素都调用此对象

```c++
for_each(wc, words.end);
```

因为我们只对`lambda`所在函数中定义的非`static`变量使用捕获列表. 一个`lambda`可以直接使用当前函数之外的名字

> 捕获列表只用于局部非静态变量的捕获, 而对于全局和局部`static`变量, 则可以直接使用



#### `lambda`捕获和返回

当定义一个`lambda`时, 编译器生成一个和`lambda`对应的新的类类型(未命名), 当向一个函数传递`lambda`时, 同时定义了一个新类型和该类型的对象: 传递参数就是此编译器生成的类类型的未命名对象. 类似的, 当采用`auto`定义一个用`lambda`初始化的变量的时候, 定义了一个从`lambda`生成的类型对象.

默认情况下, 从`lambda`生成的类都包含了一个对应该`lambda`所捕获的变量数据成员, 类似任何普通类的数据成员, `lambda`数据成员也在该`lambda`对象创建时初始化.

##### 值捕获

类似参数传递, 变量的捕获可以是值或引用, 到目前为止我们采用的都是值捕获, 与传值参数类似, 采用值捕获的前提是变量是可以拷贝的, 与参数不同, 被捕获的变量的值是在`lambda`创建时拷贝, 而不是调用时拷贝

```c++
void f() {
    size_t v1 = 42;
    auto f = [v1] { return v1; }; // v1 = 42, 构造的时候已经传值
    v1 = 0;
    auto j = f(); // j = 42
}
```

##### 引用捕获

```c++
void func2() {
    size_t v1 = 42;
    auto f = [&v1] { return v1; }; // 构造的时候已经绑定了引用
    v1 = 10;
    auto j = f(); // j = 10
}
```

引用捕获和引用返回存在相同的问题和限制， 如果我们采用引用的方式捕获一个变量, 就必须确保引用的对象在`lambda`执行过程中是存在的, `lambda`捕获的都是局部变量, 这些变量在函数结束后就不复存在, 如果`lambda`可能在函数结束后执行, 捕获的引用指向的局部变量已经消失.

但是引用捕获是有必要的, 例如`IO`对象只能采用引用的方式传递

```c++
void biggies(vector<string> & words, vector<string>::size_type sz, ostream & os = cout, char c = ' ') {
    for_each(words.begin(), words.end(), [&os, c](const string & s) { os << s << c});
}
```

由于我们不能拷贝`os`对象, 因此捕获`os`的唯一方法就是引用捕获

> 当采用引用方式捕获变量的时候, 必须保证在`lambda`执行时变量是存在的



> Tips: 尽量保持`lambda`的变量捕捉简单化
>
> 捕获一个简单变量, 采用值捕获的方式就可以了, 如果捕获一个指针或者迭代器或者引用, 就必须确保`lambda`执行时, 上述所绑定的对象仍然存在
>
> 一般来说, 我们应该尽量减少捕获的数据量, 来避免潜在的捕获导致的问题. 如果可能应该避免捕获指针或引用



##### 隐式捕获

除了显式列出我们希望使用的来自所在函数的变量之外, 还可以让编译器根据`lambda`体中的代码来推断我们使用哪些变量. 为了指示编译器推断捕获列表, 应在捕获列表中写一个`&`或者`=`, 告诉编译采用引用捕获和值捕获的方式

```c++
wc = find_if(words.begin(), words.end(), [=](const string &s) { return s.szie() >= sz; });
```

甚至的我们可以采用隐式和显式混合的捕获, 未指定的采用推导方式, 显式声明的采用声明方式捕获.

```c++
for_each(words.begin(), words.end(), [&, c](const string & s) { os << s << c; });
for_each(words.begin(), words.end(), [=, &os](const string & s) { os << s << c; });
```

当我们采用隐式和显式混合的方式捕获时, 捕获列表的第一个元素必须是一个`&`或`=`, 此符号指定了默认捕获方式.

| []                   | 空捕获                                                       |
| -------------------- | ------------------------------------------------------------ |
| [name]               | 显式捕获                                                     |
| [&]                  | 隐式引用捕获                                                 |
| [=]                  | 隐式值捕获                                                   |
| [&, identifer_list]  | 混合推导捕获, 标识符列表采用值捕获                           |
| [=, identifier_list] | 混合推导捕获, 标识符列表采用引用捕获, 这些名字必须要在之前加上`&` |



##### 可变`lambda`

默认情况下, 对于一个值被拷贝的变量, `lambda`不会改变其值, 如果我们希望改变一个被捕获的变量的值, 就必须在参数列表首上加上`mutable`关键字. 因此可变`lambda`能省略桉参数列表

```c++
void fcn3() {
    size_t v1 = 42; // 局部变量 
    auto f = [v1] mutable { return ++v1; }; // f可以改变捕获的变量的值
    v1 = 0; // 
    auto j = f(); // j = 43
}
```

一个引用捕获的变量是否可以修改依赖于引用指向的是一个`const`类型还是一个非`const`类型

##### 指定`lambda`的返回类型

到目前为止, `lambda`所编写的都只包含单一的`return`语句, 因此我还未遇到必须指定返回类型的情况. 默认情况下, 如果一个`lambda`包含`return`之外的任何语句, 则编译器假定`lambda`返回`void`, 与其它返回`void`的函数类似, 被推断返回`void`的`lambda`不能返回值.(但是我的编译器似乎可以自动推断).

当我们需要一个`lambda`定义返回类型时, 必须使用尾置返回类型



## 关联容器

`map`类的关联容器可以采用`{{}}`的方式初始化



## 内存管理





## 拷贝控制

对于一个类, 我们总是显式或者隐式地指定此类型的对现象拷贝, 移动, 赋值和销毁时做什么. 一个类通过定义五种特殊的成员来控制这些操作:

* **拷贝构造函数**
* **赋值运算符**
* **移动构造函数**
* **移动赋值运算符**
* **析构函数**

拷贝和移动构造函数定义了当用同种类型的另一个对象初始化本对象时做什么. 拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么. 析构函数定义了当此类型对象销毁时做什么. 我们称这些操作为**拷贝控制操作**. 如果一个类没有定义上述操作, 那么编译器会自动定义缺失的操作



### 拷贝, 赋值和销毁

#### 拷贝构造函数

一个构造函数的第一个参数是自身类类型的引用, 且任何额外额参数都有默认值, 则此构造函数为拷贝构造函数

```c++
class Foo
{
public:
    Foo(); // 默认构造函数
    Foo(const Foo&); // 拷贝狗杂函数
}
```

拷贝构造函数的第一个参数必须是引用类型, 虽然我们可以定义一个接受非`const`引用的拷贝构造函数, 但此参数几乎总是一个`const`引用. 拷贝构造函数在几种情况下都会隐式的使用, 因此拷贝构造函数不应该是`explicit`

##### 合成拷贝构造函数

编译器会默认生成, 即使我们构造了其它默认构造函数, 编译器也合成拷贝构造函数. 对于某些类来说, 合成拷贝构造函数用来阻止我们拷贝该类类型的对象. 一般情况是合成拷贝构造函数直接执行栈内存拷贝. 编译器从给定对象中依次将每个非`static`成员拷贝到正在创建的对象中.

每个成员的类型决定了它如何拷贝: 类类型会使用拷贝构造函数来拷贝; 内置成员直接拷贝, 虽然不能直接拷贝数组, 但是拷贝构造函数直接占内存拷贝.

##### 拷贝初始化

理解拷贝初始化和直接初始化差异:

当使用直接初始化, 实际上编译器要求使用普通的函数匹配. 当使用拷贝初始化时, 我们要求编译器将右侧运算对象拷贝到正在创建的对象中, 如果需要的话还要进行类型转化.

拷贝初始化通常使用拷贝构造函数完成, 但是如果一个类有一个移动构造函数, 则拷贝初始化有时会使用移动构造函数而非拷贝构造函数. 

```c++
string dots(10, '.'); //直接调用构造函数, 直接初始化
string s(dot); // 直接调用拷贝构造函数, 直接初始化
string s2 = dots; // 没有直接调用构造函数, copy初始化
string null_book = "9-9999-9999"; // copy初始化
string nlines = string(100, '9'); // 拷贝初始化
```

拷贝初始化不仅在定义变量`=`时发生, 以下情况也会发生:

* 将一个对象作为实参传递给一个非引用类型的形参
* 从一个返回类型为非引用的函数返回一个对象
* 用花括号列表初始化一个数组中的元素或者一个聚合类的成员



##### 参数和返回值

拷贝构造函数被用来初始化非引用类类型参数, 这一特性解释了为什么拷贝构造函数自己的参数必须时引用类型, 如果不是引用类型, 则调用永远也不会成功, 为了调用拷贝构造函数, 我们必须拷贝它的实参, 但为了拷贝实参, 我们又需要调用拷贝构造函数, 如此无限循环.

> 也就是说拷贝构造函数的参数必须是个引用, 否则不是引用的话将会无限循环



##### 拷贝初始化的限制

如果我们使用初始值要求通过一个`explicit`的构造函数来进行类型转换. 那么使用拷贝初始化还是直接初始化就无所谓了.

```c++
vector<int> v1(10);
vector<int> v2 = 10; // 接受大小参数的构造函数是explicit的
void f(vector<int>); // f的参数进行拷贝初始化
f(10); // 错误, explicit构造函数无法隐式使用
f(vector<int>(10)); // 正确
```

##### 编译器可以绕过拷贝构造函数

在拷贝初始化的过程中, 编译器可以(但不是必须)跳过拷贝/移动构造函数, 直接创建对象

```c++
string null_book = "9999999"; // 改写如下
string null_book("999999"); // 编译器掠过了拷贝构造函数
```

但是即使编译器掠过了拷贝/移动构造函数, 但是在这个点上, 拷贝/移动构造函数必须存在且可访问;



#### 拷贝赋值运算符

赋值运算符如果未定义, 编译器会为它合成一个

##### 重载赋值运算符

重载运算符的本质是一个函数, 其名字由`operator`关键字后接定义的运算符的符号组成. 因此赋值构造函数是一个名字为`operator=`函数, 类似于其它函数, 运算符函数也有一个返回类型和一个参数列表.

重载运算符的参数列表表示运算符的运算对象. 某些运算符, 包括赋值运算符, 必须定义为成员函数. 如果一个运算符是一个成员函数, 其左侧运算对象就绑定到隐式`this`参数. 对于一个二元运算, 例如赋值运算符, 其右侧运算对象作为显式参数传递.

```c++
class Foo
{
public:
    Foo &operator=(const Foo &); // 赋值运算符
};
```

为了和内置赋值运算符报纸一致, 赋值运算符通常返回一个指向其左侧运算对象的引用. 另外值得注意的是标准库通常要求保存在容器中的类型要具有赋值运算符, 且返回值是左侧运算对象的引用.

> 赋值运算符通常应该返回一个指向其左侧运算对象的引用



##### 合成拷贝赋值运算符

如果未自己定义, 那么编译器会自己生成一个合成拷贝赋值运算符. 类似拷贝构造函数, 对于某些类, 合成拷贝赋值运算符用来禁止该类型对象的赋值. 也就是逐个赋值, 返回左侧运算对象的引用



#### 析构函数

析构函数执行和构造函数相反的操作: 构造函数初始化对象的非`static`成员, 还能做一些其它的工作, 析构函数释放对象使用的资源, 并销毁非`static`数据成员

```c++
class Foo
{
public:
    ~Foo();
};
```

##### 析构函数完成什么工作

> 隐式销毁一个内置指针类型的成员不会`delete`它所指向的对象

##### 什么时候会调用析构函数

无论何时一个对象被销毁, 就会自动调用析构函数:

* 变量在离开其作用域时被销毁
* 当一个对象被销毁时, 其成员被销毁
* 容器被销毁时, 元素被销毁
* 对于动态分配内存的对象, 当指向它的指着应用`delete`运算符时被销毁
* 对于临时对象, 当创建它的完整表达式结束时被销毁

> 当指向一个对象的引用或指针离开作用域时, 析构函数不会执行

##### 合成析构函数

当一个类未定义自己的析构函数时, 编译器会为它定义一个合成析构函数, 一般为空.



#### 三/五法则

##### 需要析构函数的类也需要拷贝和赋值操作

> 略

##### 需要拷贝操作的类也需要赋值操作, 反之亦然

比如每个对象都有一个自己的独特序列号, 如此一来你就需要重写拷贝构造函数和拷贝赋值运算符, 而不需要管析构函数.



#### 使用`=default`

通过将拷贝控制成员定义为`=default`来显式的要求编译器生成合成的版本.

```c++
class T
{
public:
    T() = default;
    T(const T &) = default;
    T& operator=(const T &);
    ~T() = default;
};

T& T::operator=(const T&) = default; // 我们不希望内联的时候
```

#### 阻止拷贝

> 大多数类应该定义默认构造函数, 拷贝构造函数和拷贝赋值运算符, 无论隐式还是显式地

有些时候定义这些拷贝操作没有什么意义, 在这种情况下必须采用某种机制阻止拷贝或者赋值. 例如`IO`阻止拷贝和赋值, 避免多个对象读入和或读取相同的`IO`缓存

##### 定义删除的函数

新标准允许我们通过将拷贝构造函数和拷贝赋值运算符定义为**删除的函数**来阻止拷贝. 删除的函数是一种函数: 我们虽然声明了它, 但不能以任何方式使用它们, 参函数的参数列表后加上`= delete`即可

```c++
struct NoCopy
{
    NoCopy() = default;
    NoCopy(const NoCopy &) = delete;
    NoCopy & operator=(const NoCopy &) = delete;
    ~NoCopy() = default;
};
```

`= delete`告诉编译器我们不希望定义这些成员, 并且第一次声明出现的时候就使用. 我们可以对任何函数指定为` = delete`, `= default`只能对编译器合成的默认构造函数或拷贝控制成员使用`=default`

##### 析构函数不能是删除的成员

我们不能删除析构函数, 如果析构函数删除了, 就无法销毁此类型的对象了. 对于一个删除了析构函数的类型, 编译器将不允许定义该类型的变量或创建该类的临时变量

> 对于析构函数删除的类型, 不能定义该类型的变量或释放执行该类型动态分配的对象.



##### 合成的拷贝构造函数是可删除的

* 类的某个成员的析构函数是删除的或者不可访问的(`private`), 则类的合成析构函数被定义成删除的
* 同理拷贝构造函数
* 同理赋值运算符, 并且类有一个`const`的或者引用成员, 则类的赋值运算符是删除的

> 重点需要再看

本质上, 如果一个类有数据成员不能默认构造, 拷贝, 复制或者销毁, 则对应的成员函数都将定义为删除.

> 本质想当不可能拷贝, 赋值或者销毁类的成员的时候, 类的合成拷贝控制成员就被定义为删除



##### private拷贝控制

> 略



## 重载运算和类型转换

略



## 面向对象程序设计

### OOP概述

##### 继承

根部的称为基类, 继承得到的称为派生类. 基类负责在层次中所有类共同拥有成员, 派生类定义各自的成员

如果基类希望它的派生类各自定义适合自身的版本, 此时基类就将函数声明为**虚函数**.

```c++
class T
{
    virtual void f() const;
};
```

派生类必须使用**派生类列表**指名它是从哪个基类继承而来的, 形式如下:

```c++
class A: public B, private C, protected D ...
{

};
// 如果进行了重写要加上override
```

派生类必须在其内部对所有重新定义的虚函数(一般来说)进行声明, 派生类在这样的函数之前可以加上`virtual`也可以不加.



##### 动态绑定

函数的运行版本由实参决定, 在运行时选择函数的版本, 所以动态绑定又称为**运行时绑定**.



### 定义基类和派生类

#### 定义基类

作为继承关系中的根节点的类通常都会定义一个虚析构函数

```c++
class A
{
public:
    A() = default;
    virtual double net_price() const;
    virtual ~A() = default; // 对析构函数进行动态绑定
}
```



> 基类通常都应该定义一个虚析构函数, 即使该函数不执行任何实际操作



##### 成员函数与继承

派生类可以继承其基类的成员, 然而当遇到`virtual`这样的函数时, 派生类必须对其进行重新定义. 也就是派生类需要对这些操作提供自己的新定义以**覆盖**从基类继承而来的旧定义.

基类将两种成员函数区分开:

* 基类希望派生类覆盖的函数, **虚函数**, 当采用指针或引用调用虚函数的时候, 该调用将被动态绑定. 根据引用或者指针所绑定的对象类型不同, 该调用可能执行基类版本, 也可能执行派生类版本.
* 基类希望派生类直接继承而不改变的函数

基类成员可以通过在成员函数之前加上`virtual`使得函数执行动态绑定. 任何构造函数之外的非静态成员都可以成为虚函数. 关键字只能出现在类内部, 无法出现类外部. 如果基类把一个函数声明为虚函数, 那么函数在派生类中也隐式地为虚函数.

否则, 如果没有就是静态绑定.

##### 访问控制与继承

派生类可以继承定义在基类中的成员, 但是派生类不一定有权限访问基类继承而来的函数.



#### 定义派生类

派生类必须使用**派生类列表**明确指出从哪个基类继承而来.



##### 派生类中的虚函数

派生类经常覆盖它继承的虚函数. 否则的话就是直接继承在基类的版本. 派生类可以在他覆盖的函数前采用`virtual`关键字(不一定要写). 新标准允许我们在形参列表之后添加`override`



##### 派生类对象及派生类对象向基类的类型转换.

派生类包含:

* 派生类自己定义的成员的子对象
* 以及一个该派生类的基类对应的子对象

因此可以把基类的指针或引用绑定到派生类对象中的基类部分上. 可以隐式执行.

> 在派生类中含有基类对应的组成部分, 这是继承的关键所在.

##### 派生类构造函数

> 每个类控制自己成员的初始化过程, 派生类必须使用基类的构造函数来初始化它的基类部分

派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数

除非我们特别指出, 否则派生类对象的基类部分会像数据成员一样执行默认初始化. 如果想要使用其他的基类构造函数, 需要以显式调用基类的构造函数.

> 首先初始化基类, 然后按照声明顺序执行派生类成员.



##### 派生类使用基类成员

派生类可以访问基类的公有成员和受保护成员. 需要了解到派生类的作用域嵌套在基类的作用域之内. 因此对于派生类的一个成员来说, 它使用派生类成员的方式与使用基类成员方式没有什么不同

> 我们应当尽量遵循基类的接口.



##### 继承和静态成员

如果基类定义了一个静态成员, 则在整个**继承体系**中只存在该成员的唯一定义. 不论从基类派生出多少个派生类来. 对于每个静态成员来说都只存在唯一实例.  静态成员遵循通用的访问控制规则, 如果基类中的成员是`private`的, 派生类也无权访问, 假设是静态可访问的, 则通过派生类和基类都可以访问



##### 派生类声明

派生类的声明只包含类名, 不包含派生列表.



##### 被用作基类的类

如果我们想某个类作为基类, 则该类必须要以及定义. 隐含意味着一个类不能派生它自己.

每个类都会继承直接基类的所有成员, 对于一个最终的派生类来说, 它会继承其直接基类成员; 该基类的成员又含有其基类成员, 依次类推到继承顶端.



##### 防止继承发生

新标准提供在类名之后添加关键字`final`意味着防止继承发生

```c++
class NoDerived final { };
```



#### 类型转化和继承

> 理解基类和派生类之间的类型转化是`c++`关键

例外, 我们可以将基类的指针或引用绑定到派生类对象上. 最重要的含义是, 当使用基类的引用或者指针时, 实际上我们不清楚该引用(指针)绑定的对象的真实类型. 该对象可能时基类的, 也可能时派生类的.

> 智能指针也支持派生类向基类的类型转换

##### 静态类型和动态类型

采用继承时必须要将变量或者表达式的**静态类型**和该表达式的**动态类型**区分开. 表达式的静态类型在编译时总是已知的, 它是变量声明时的类型或者表达式的生成类型; 动态类型则是变量或表达式表示的内存中的对象的类型. 动态类型直到运行时才知道.

> 基类的指针或者引用可能和其动态类型不一致

##### 不存在从基类向派生类的隐式类型转化

无论如何都不不会用隐式的类型转化. 但是你可以强转. 如果基类含有一个或者多个虚函数, 那么可以采用`dynamic_cast`请求类型转化; 如果我们已经知道某个基类向派生类的转化是安全的, 则可以采用`static_cast`



##### 在对象之间不存在类型转换

派生类向基类的自动类型转化只对指针或引用有效, 对于类型之间的转化则不存在这样的转换.

如果我们将一个派生类对象赋值/初始化一个基类对象, 那么就会调用基类的赋值运算符/拷贝构造函数, 即使一般传递的是引用, 但是也不存在动态绑定, 因此基类只能处理的只有自己那部分成员.

也就是会导致派生类被切掉一部分

> 当将一个派生类对象为一个基类对象初始化或赋值时, 只有该派生类对象中的基类部分会被拷贝, 赋值或者移动, 派生部分会被忽略



### 虚函数

`c++`只有采用指针或者引用才能执行动态绑定.

##### 对虚函数的调用可能在运行时才被解析

> C++运用了指针的静态类型和动态类型不一致的思想, 支持多态

##### 派生类中的虚函数

当我们在派生类中覆盖了某个虚函数的时候, 可以再次采用`virtual`指出该函数的性质, 虽然指不指出都是虚函数.

要想覆盖必须要一摸一样. **但是返回指针时存在例外**

> 基类中的虚函数默认还是虚函数, 要想进行覆盖, 则形参必须严格匹配

##### `final`和`override`说明符

`overide`使得编译器参加进入检查, 只有虚函数才能被覆盖(override), 否则编译器会报错.

我们还可以把函数指定为`final`, 则意味着任何尝试覆盖该函数都将引发错误.

它们俩出现在任何符号之后

##### 虚函数和默认实参

默认实参由调用的静态类型决定

##### 回避虚函数机制

有些时候我们不希望虚函数进行动态绑定, 而是强制执行某一个版本, 我们可以采用作用域解析运算符指名我们需要的版本.

```c++
double undiscounted = baseP->Quote::net_price(42);
```

该调用将在编译时完成解析

> 通常情况下只有成员函数(友元)中的代码才需要作用域解析运算符来回避虚函数机制.

> 如果一个派生类虚函数需要调用它的基类版本, 但是没有是使用作用域解析运算符, 则在运行的时候将导致无限循环



### 抽象基类



##### 纯虚函数

我们不希望用户可以创建这个基类的对象. 因此我们可以将一个函数定义成纯虚函数.

纯虚函数清晰的告诉我们告诉我们这个函数没有实际的意义, 这个纯虚函数无须定义. 我们通过在函数体的位置书写`=0`就可以将一个虚函数说明为纯虚函数, 其中`=0`只能出现在类内部的虚函数声明语句处;

```c++
class A
{
public:
    double net_price() const = 0;
}
```

值得注意的是, 这个类无法直接定义一个对象, 但是它的构造函数可以用来作为派生类的部分构造. 值得注意的是, 我们可以为纯虚函数提供定义, 不过函数体定义在类的外部, 也就是说我们不能在类的内部为一个`=0`的函数提供载体.



##### 含有纯虚函数的类是抽象基类

含有纯虚函数的类称为**抽象基类**, 抽象基类负责定义接口, 而后续的其它类可以覆盖该接口. 我们不能直接创建一个抽象类的对象. 我们可以定义抽象基类的派生类对象, 前提是纯虚函数被实现.

> 我们无法创建抽象基类的对象

##### 派生类构造函数只能初始化它的直接基类

每个类各自控制其对象的初始化过程. 各自调用自己的父类构造函数, 完成自己的调用.



### 访问控制与继承

每个类分别控制自己的成员初始化过程. 每个类还分别控制着其成员对于派生类来说是否可访问.

##### 受保护成员

一个类采用`protected`关键字声明:

* 和私有成员类似, 受保护的成员对于类的用户来说是不可访问的
* 和公有成员类似, 受保护的成员对于派生类的成员和友元来说是可访问的.
* 派生类的成员或友元只能通过派生类对象来访问基类受保护成员. 派生类对于一个基类对象中的受保护成员没有任何访问特权。

```c++
class Base
{
protected:
    int prot_mem;
};

class Sneaky: public Base
{
 friend void clobber(Sneaky &); // 可以访问Sneaky::promt_mem;
 friend void clobber(Base &); // 无法访问Base::promt_mem;
 int j;
}

// 总结一句话: 派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员, 对于普通基类对象中的成员不具有任何访问权限
```

##### 共有, 私有和受保护继承

某个类对其继承而来的成员访问权限受到两个因素的影响:

* 基类中该成员的访问说明符
* 派生类列表中的访问说明符

派生访问说明符的目的是控制派生类用户对于基类成员的访问权限, 派生访问说明符还可以控制继承自派生类大当新类的访问权限



##### 派生类向基类转换的可访问性 

派生类向基类的转换是否可访问由使用该转换的代码决定, 同时派生类的派生访问说明符也会影响, 假定D继承自B:

* 只有当D公有地继承自B时, 用户代码才能使用派生类向基类地转换: 如果D继承B的方式时受保护或者私有的, 则用户代码不能使用该转换
* 不论以什么方式继承B, D的成员函数和友元都能使用派生类向基类的转换: 派生类向其直接积累的类型转换对于派生类的成员和友元来说永远是可访问的.
* 如果D继承自B的方式是公有的或者受保护的, 则D的派生类的成员可以使用D向B的类型转换, 反之, 如果D继承B的方式是私有的

> 对于代码中的某个给定的节点来说, 如果基类的公有成员是可访问的, 则派生类向基类的类型转化也是可访问的



> 类的受保护成员和类的设计



##### 友元与继承

友元关系无法传递, 同样无法继承. 基类的友元在访问派生类成员时不具有特殊性, 类似的派生类的友元也不能随意访问基类的成员.

每个类各自管理其访问权限. 访问权限包括了内嵌对象.

> 不能继承友元关系, 每个类负责控制各自成员的访问权限
>
> 同样每个类各自负责其非静态成员

##### 改变个别成员的可访问性

有时我们需要改变派生类继承某个名字的访问级别, 通过采用`using`声明可以达到

```c++
class D: private Base
{
public:
    using Base::size; // 改变成员访问权限
}
```

> 派生类只能为那些它可以访问的名字提供`using`声明

##### 默认的继承保护级别

采用`struct`默认派生继承为`public`, `class`默认为`private`

### 继承中的类作用域

每个类定义自己的作用域, 在这个作用域内我们定义类的成员. 当继承关系存在的时候, 派生类的作用域嵌套在基类的作用域之内. 如果一个名字在派生类的作用域无法正确解析, 则编译器将继续在外层的基类作用域中寻找该名字.

派生类的作用域位于基类的作用域之内这一事实可能令人出乎意料, 不过恰恰因为类作用域有这种继承嵌套关系, 所以派生类才能像使用自己的成员一样使用基类的成员.



##### 在编译时进行名字查找

一个对象, 引用或指针的静态类型决定了该对象的哪些成员是可见的. 即使静态类型和动态类型可能不一致, 但是我们能使用哪些成员仍然有静态类型决定.



##### 名字冲突和继承

和其它作用于一样, 派生类也能重新定义在其直接基类或间接基类中的名字, 此时定义在内层作用域的名字将隐藏在外层作用域基类的名字

> 派生类的成员将隐藏同名的基类函数

##### 通过作用域运算符来使用隐藏的成员

```c++
Base::mem;
::mem;
```

>  除了覆盖继承而来的虚函数之外, 派生类最好不要重用其它定义在基类中的名字

> 关键概念： 名字查找和继承
>
> 理解函数调用的解析过程对于理解c++的继承十分重要, 假定我们调用`p->mem()`, 则依次执行以下四个步骤:
>
> * 首先确定p的静态类型, 因为我们调用的是一个成员, 因此该类型必然是类类型
> * 在p的静态类型中查找mem, 如果找不到, 则依次在直接基类中不断查找直到达到继承链的顶端, 否则编译器将报错.
> * 一旦找到了mem, 就进行常规的类型检查, 以确定当前找到的mem
> * 假设调用合法, 则编译器将根据调用的是否是虚函数而产生不同的代码:
>   1. 如果是虚函数且我们通过引用或者指针进行的调用, 则编译器产生的代码将在运行时决定运行虚函数的哪个版本, 依据的是对象的动态类型
>   2. 反之, 如果mem不是虚函数, 或者我们采用对象进行调用, 则编译器将产生一个常规函数的调用

##### 一如往常名字查找先于类型检查

声明在内层作用域的函数并不会重载声明在外层作用域的函数.(重载针对的是相同作用域的同名函数), 因此定义在派生类中的函数也不会重载其基类中的函数. 和其它作用域一样, 如果派生类的成员和基类成员的某个成员同名, 则派生类将在其作用域内隐藏该基类成员. 即使派生类成员和基类成员的形参列表不一致, 基类成员也会被隐藏

## 格式化输出

### 重定向



### 使用`cout`进行输出

* 重载`<<`运算符

* 



### 格式化

* `setw(width)`设定输出宽度, 也就是右对齐的输出, 如果不足`width`将会自动填补空格

* `hex(cout)`或者`cout << hex`可以指定16进制输出, 同理含有`oct`八进制, `dec`十进制

* 字段宽度可以采用`cout.width(wid)`, 或者采用`cout << setw(wid)`来指定输出宽度, **警告`width`仅仅影响接下来的一个项目, 然后会恢复原状, 并且C++更注重内容**

* `cout.fill('')`可以用来填充控白

* 设置浮点数精度, 默认精度为6, `cout.precision(n)`可以用来表示精度, **它和`fill()`一样, 新的设置精度将会一直有效, 直到被重新设置, 自动四舍五入**

* 打印末尾的0和小数点, 采用`cout.setf(ios_base::showpoint)`

* `setf`详解

  仅设置一位

  | `ios_base::boolalpha` | 输入和输出bool值, 显式true和false |
  | --------------------- | --------------------------------- |
  | `showbase`            | 对于输出, 采用C++前缀`0`和`0x`    |
  | `showpoint`           | 显式末尾小数点                    |
  | `uppercase`           | 对于16进制采用大写字母            |
  | `showpos`             | 在正数前加`+`                     |

  设置两位

  第二个参数为`basefield`的时候:

  1. `dec`, `hex`, `oct`

  第二个参数为`floatfield`的时候

  1. `fixed`采用顶点计数法
  2. `scientific`采用科学计数法

  第二个参数为`adjustfield`的时候

  1. `left`表示左对齐
  2. `right`表示右对齐
  3. `internal`符号或者基数前缀对齐, 值右对齐



### 头文件`iomanip`

* `setfill(char)`设置填充值, 注意宽度是从输出之后开始进行



### 简单的文件I/O

要让程序写入文件, 必须要这样做:

* 创建一个`oftream`对象管理输出流
* 将该对象与特定的文件关联
* 以使用`cout`的方式使用该对象, 唯一区别是将输出进文件, 而不是屏幕

```c++
#include <fstream>
ofstream fout;
fout.open("file.txt");
ofstream fout("file.txt"); // 直接构造的时候使用

```

输入流的处理方式同理.

使用完之后要进行关闭



