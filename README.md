# CPP-For-Future

> 这是一个面向未来的C++, 从C语言角度看C++

[toc]

## 基本概念



### 变量和基本数据类型

#### 内置基本类型

* 算术类型

  也就是基本的C语言数据类型以及后来的`bool`类型, 为了使C++具有更好的平台兼容性, 我们可以使用固定尺寸的数据类型, 例如: `int_32`, `int_64`等等

* 空类型

  `void`类型

* 有符号和无符号类型



> 基本上和C语言的类型没有太大差异

#### 类型转换

一般来说对于循环中的计数变量, 请不要将之定义为**无符号**类型.

##### 字面值常量

* 整型和浮点型字面值

  还是和C语言的一致

* 字符和字符串面值

* 转义序列

* 指定字面值类型

  1. `L`前缀指定`wchart_t`类型
  2. `u8`前缀指定字符串面值为`utf-8`格式
  3. `U`后缀指定无符号类型
  4. `u`前缀指定`unicode 16`字符, `U`前缀指定`unicode_32`字符
  5. `L`指定`long`类型



### 变量定义

变量的基本类型首先是**类型说明符**, 随后紧跟一个或者多个变量名组成的列表, 其中变量名以逗号分隔, 最后以分号结束

> 什么是对象?
>
> 对象是具有某种数据类型的内存空间

####  初始值

当对象在创建时获得了特定值, 称之为对象被**初始化**了

> 初始化不是赋值, 初始化的含义是创建变量时赋予其一个初始值, 而赋值的含义是把对象的当前值擦除, 而以一个新值来替代

#### 列表初始化

* 采用C语言`=`的方式进行初始化
* 采用花括号`{}`方式进行初始化, 这种初始化方式称为**列表初始化**, 这种初始化可以避免变量**窄缩**

####  默认初始化

如果定义变量时没有指定初始化值, 则变量将会**默认初始化**, 此时变量被赋予默认值, 这个值是什么由变量类型和定义位置决定.

* 如果内置类型未被显式初始化, 它的值由定义位置决定. **定义于任何函数体之外的变量被初始化为0**. 定义在函数体内部的内置类型变量将**不被初始化**, 也就是其中的值为**垃圾值**.
* 每个外部类自行决定初始化对象的方式, 绝大多数类都支持无须显式初始化而定义对象, 这样的类提供了合适的默认值., 例如`string`
* 还有一些类要求每个对象都显示初始化



#### 变量声明和定义关系

为了允许把程序拆分成多个逻辑部分来编写, `C++`支持**分离式编译**机制, 即将程序分割为若干文件, 每个文件可以独立编译; 为了将程序分为多个文件, 则需要在文件间共享代码的方法.

`C++`将声明和定义区分开. **声明**使得名字为程序所知, 一个文件如果想要使用别处定义的名字则必须包含对那个名字的声明. 而**定义**负责创建和名字关联的实体. 声明规定了变量的类型和名字, 而定义还申请存储空间, 也可能为变量赋值一个初始化值.

*  如果想声明一个变量而非定义它, 就在变量名前添加关键字`extern`, 任何包含了初始化的声明都会导致内存分配, 从而使声明变成定义.**尤其要注意一点, 变量只能定义一次, 但是可以多次声明**

> 静态类型
>
> `C++`是一种**静态类型**语言, 也就是在编译阶段检查类型. 其中, 检查类型的过程中称为**类型检查**




### 标识符

变量名规范继承了`C`语言的传统



### 作用域

同一个名字在不同的作用域可能指向不同的实体. 名字有效区域始于名字的声明语句, 以声明语句所在的作用域末端为结束. 而作用域以花括号`{}`进行定义

* 名字定义于所有的花括号之外拥有全局作用域, 从声明处开始具有域的范围
* 在同一个作用域存在多个同名变量的话采用**局部优先**原则



### 复合类型

基本的复合类型: **指针**和**引用**



#### 引用

一般的引用为**左值引用**, 引用相当于为**对象**另外起了一个名字, 采用`T &`来表示这是一个引用类型, 引用**必须在定义的时候初始化**, 定义引用时, 程序把引用和初始值**绑定binding**到一块, 也就是**别名**.

如果我们采用的是直接赋值, 相当于是在开辟了一个存储空间, 再将值**copy**到新内存当中.

> 由于引用本身不是一种类型, 只是一个别名, 因此不允许定义一个引用的引用(因为标准说不行)



特殊情况:

* 左值引用必须要对象进行绑定, 而不能和**字面值和表达式**绑定
* 左值引用必须要类型匹配



#### 指针

**指针**指向另外一种类型的的符合类型, 我想跳过这一节, 因为相比于`C`, 指针在`C++`没有太多扩展.

* 空指针不指向任何类型, 在试图对一个指针进行操作的时候首先要检查它是否为空, 采用`nullptr`来表示空指针. `nullptr`可以被转换为任意其它类型的空指针.
* `void*`指针, 它可以指向任何数据类型, 但是无法取对象, 因此取对象的时候我们需要进行强制转换

一般遇到类型复杂的时候, **我们采用从右向左读的方式进行类型解析**



### `const`限定符

`const`对象被创建之后它的值就不能被改变了, 所以它必须进行初始化

#### 默认情况下`const`对象仅在文件内有效

如果多个文件中都想使用`const`定义的变量, 我们必须在**每个使用到它的文件中都单独的进行定义**, 因此默认情况下**`const`被设定为仅在当前文件内有效**, 如果我们想要在多个文件中进行共享那么**不管定义还是声明我们都需要在它之前添加`extern`**

```c++
// file1.cpp中定义一个const常量
extern const int bufSize = fcn();

// file2.cpp中我们可以进行引用
extern const int bufSize;
```

#### `const`引用

可以把引用绑定到`const`对象上, 我们称之为**对`const`的引用**, 和普通引用所不同的是, 对常量的引用不能改变它所绑定的对象, 也就是这种引用表名**它所引用的对象都是常量, 包括基本类型**

#### 初始化和对`const`的引用

一般来说引用的类型必须要和所引用对象的类型保持一致, 但是存在两个例外:

1. 初始化常量引用的时候允许用任意表达式作为初始值, 只要该表达式的结果能转换成引用的类型即可. 尤其, 允许一个常量引用绑定非常量的对象, 字面值甚至一般表达式

   可是该如何理解这种行为呢? 实际上编译器做了优化

   ```c++
   double dval = 3.14;
   const int & ri = dval;
   // 上面是一个很正确的C++引用的赋值
   
   // 实际上编译器做了如下的优化
   const int temp = dval;
   const int &ri = temp;
   // 也就是在引用过程中产生了一个临时的整型常量, 也就是所说的临时量
   ```

   **临时量**就是引用表达式, 和类型不匹配时编译器的解决方法

2. 对`const`的引用可能并非引用一个`const`对象



#### 指针和`const`

这一点和`C`语言并没有什么不同, `const`在前表示指向的值无法改变, `const`在后表示指针无法被改变;

`const`指针意味着指向常量的指针, 因此可以用指向**常量**



### 顶层`const`

**顶层`const`**表示指针本身是一个常量, **底层`const`**表示指针所指的对象为一个常量, **因此, 我们可以通过判断变量本身是否可变来表示顶层和底层**(自己最大)



### `constexpr`和常量表达式

**常量表达式**是指值不会改变并且在编译过程就能得到计算结果的表达式. 显然字面值属于常量表达式. 采用常量表达式初始化的`const`对象也是常量表达式.

一个对象是不是常量表达式由它的数据类型和初始值共同决定, 例如:

```c++
const int max_files = 20; // max_file常量表达式
const int limit = max_file + 1; // limit是常量表达式
int staff_size = 27; // 不是常量表达式
```

#### `constexpr`变量

允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式. **声明为`constexpr`的变量一定是一个常量, 而且必须用常量表达式初始化**:

```c++
constexpr int mf = 20;
constexpr int limit = mf + 1;
constexpr int sz = size(); // 只有当size是一个constexpr函数时才是一条正确的声明语句
```

新标准允许定义一种特殊`constexpr`函数, 这种函数简单到足以在编译的时候就计算结果, 这样就能用`constexpr`函数去初始化`constexpr`变量了.

> 一般来说, **如果你认为变量是一个常量表达式, 那么就把它声明为`constexpr`类型**



### 字面值类型

常量表达式的值在编译时就得到计算, 因此对声明`constexpr`时用到的类型必须有所限制, 一般把这些类型称为**字面值类型**. 到目前为止接触过的数据类型中:

* 算术类型
* 引用
* 指针

都属于字面值类型. **尽管指针和引用都能定义成`constexpr`**, 但`constexpr`指针的初始值必须是`nullptr`或者`0`, 或者是存储于某个固定地址中对象.  函数体内定义的变量一般来说并非存放在**固定地址中**, 因此`constexpr`指针不能指向这样的变量. 定义于所有函数体之外的对象其地址**固定不变**. 因此`constexpr`能绑定到这样的变量上, `constexpr`指针也能指向这样的变量.



#### 指针和`constexpr`

在`constexpr`声明中如果定义了一个指针, 限定符`constexpr`仅对指针有效, 与指针所指的对象无关

```c++
constexpr int *q = nullptr; // q是一个指向整数的常量指针
// q是一个常量指针, constexpr把它所定义的对象置为了顶层const
```



### 处理类型

#### 类型别名

**类型别名**是否中类型的同义词, 可以让复杂类型名字变得简单明了, 易于理解和使用, 有两种方法可用于定义类型别名:

* `typedef`

  ```c++
  typedef double wages;
  typedef wages base, *p;
  ```

  `typedef`作为声明语句前缀之后, 变量名就代表了类型别名, 这里和`C`的用法一致.

* `using`

  新标准规定了**别名声明**来定义类型的别名

  ```c++
  using SI = Sales_item; // SI是Sales_item的同义词
  ```

  这种方法用关键字`using`作为别名声明的开始, 其后紧跟别名和等号, 其作用是把等号左侧的名字规定成等号右侧类型的别名.

#### 指针, 常量和类型别名

```c++
typedef char *pstring;
const pstring cstr = 0; // cstr是指向char的常量指针
const pstring *ps; // ps是一个指针, 它的对象是指向char的常量指针
```

可以这样解释: `pstring`是一个指向`char`的指针, 那么`const pstring cstr = 0`就是一个常量指针指向`char`



### `auto`类型说明符

可以让编译器代替我们去分析表达式所属的类型, 显然`auto`定义的变量必须要有初始值.

#### 符合类型, 常量和`auto`

* 遇到引用时, 以引用中值的类型作为`auto`类型

* `auto`会忽略掉**顶层`const`**, 同时**底层`const`**会被保留下来, 比如**指向常量的指针**

  ```c++
  const int ci = i, &cr = ci;
  auto b = ci; // b是一次整数
  auto c = cr; // c是一个整数
  auto d = &i; // d是一个整型指针
  auto e = &ci; // e是一个指向整型常量的指针(对常量对象取地址是一种底层const)
  ```

* 如果希望`auto`推断出顶层`const`, 需要指出

  ```c++
  const auto f = ci; // ci为int, f是const int
  ```

* 还可以将引用类型设为`auto`

  ```c++
  auto &g = ci; // g是一个整型常量引用
  auto &h = 42; 
  const auto &j = 42;
  ```

  



