# CPP-For-Future

> 这是一个面向未来的C++, 从C语言角度看C++

[toc]

## 基本概念



### 变量和基本数据类型

#### 内置基本类型

* 算术类型

  也就是基本的C语言数据类型以及后来的`bool`类型, 为了使C++具有更好的平台兼容性, 我们可以使用固定尺寸的数据类型, 例如: `int_32`, `int_64`等等

* 空类型

  `void`类型

* 有符号和无符号类型



> 基本上和C语言的类型没有太大差异

#### 类型转换

一般来说对于循环中的计数变量, 请不要将之定义为**无符号**类型.

##### 字面值常量

* 整型和浮点型字面值

  还是和C语言的一致

* 字符和字符串面值

* 转义序列

* 指定字面值类型

  1. `L`前缀指定`wchart_t`类型
  2. `u8`前缀指定字符串面值为`utf-8`格式
  3. `U`后缀指定无符号类型
  4. `u`前缀指定`unicode 16`字符, `U`前缀指定`unicode_32`字符
  5. `L`指定`long`类型



### 变量定义

变量的基本类型首先是**类型说明符**, 随后紧跟一个或者多个变量名组成的列表, 其中变量名以逗号分隔, 最后以分号结束

> 什么是对象?
>
> 对象是具有某种数据类型的内存空间

####  初始值

当对象在创建时获得了特定值, 称之为对象被**初始化**了

> 初始化不是赋值, 初始化的含义是创建变量时赋予其一个初始值, 而赋值的含义是把对象的当前值擦除, 而以一个新值来替代

#### 列表初始化

* 采用C语言`=`的方式进行初始化
* 采用花括号`{}`方式进行初始化, 这种初始化方式称为**列表初始化**, 这种初始化可以避免变量**窄缩**

####  默认初始化

如果定义变量时没有指定初始化值, 则变量将会**默认初始化**, 此时变量被赋予默认值, 这个值是什么由变量类型和定义位置决定.

* 如果内置类型未被显式初始化, 它的值由定义位置决定. **定义于任何函数体之外的变量被初始化为0**. 定义在函数体内部的内置类型变量将**不被初始化**, 也就是其中的值为**垃圾值**.
* 每个外部类自行决定初始化对象的方式, 绝大多数类都支持无须显式初始化而定义对象, 这样的类提供了合适的默认值., 例如`string`
* 还有一些类要求每个对象都显示初始化



#### 变量声明和定义关系

为了允许把程序拆分成多个逻辑部分来编写, `C++`支持**分离式编译**机制, 即将程序分割为若干文件, 每个文件可以独立编译; 为了将程序分为多个文件, 则需要在文件间共享代码的方法.

`C++`将声明和定义区分开. **声明**使得名字为程序所知, 一个文件如果想要使用别处定义的名字则必须包含对那个名字的声明. 而**定义**负责创建和名字关联的实体. 声明规定了变量的类型和名字, 而定义还申请存储空间, 也可能为变量赋值一个初始化值.

*  如果想声明一个变量而非定义它, 就在变量名前添加关键字`extern`, 任何包含了初始化的声明都会导致内存分配, 从而使声明变成定义.**尤其要注意一点, 变量只能定义一次, 但是可以多次声明**

> 静态类型
>
> `C++`是一种**静态类型**语言, 也就是在编译阶段检查类型. 其中, 检查类型的过程中称为**类型检查**




### 标识符

变量名规范继承了`C`语言的传统



### 作用域

同一个名字在不同的作用域可能指向不同的实体. 名字有效区域始于名字的声明语句, 以声明语句所在的作用域末端为结束. 而作用域以花括号`{}`进行定义

* 名字定义于所有的花括号之外拥有全局作用域, 从声明处开始具有域的范围
* 在同一个作用域存在多个同名变量的话采用**局部优先**原则



### 复合类型

基本的复合类型: **指针**和**引用**



#### 引用

一般的引用为**左值引用**, 引用相当于为**对象**另外起了一个名字, 采用`T &`来表示这是一个引用类型, 引用**必须在定义的时候初始化**, 定义引用时, 程序把引用和初始值**绑定binding**到一块, 也就是**别名**.

如果我们采用的是直接赋值, 相当于是在开辟了一个存储空间, 再将值**copy**到新内存当中.

> 由于引用本身不是一种类型, 只是一个别名, 因此不允许定义一个引用的引用(因为标准说不行)



特殊情况:

* 左值引用必须要对象进行绑定, 而不能和**字面值和表达式**绑定
* 左值引用必须要类型匹配



#### 指针

**指针**指向另外一种类型的的符合类型, 我想跳过这一节, 因为相比于`C`, 指针在`C++`没有太多扩展.

* 空指针不指向任何类型, 在试图对一个指针进行操作的时候首先要检查它是否为空, 采用`nullptr`来表示空指针. `nullptr`可以被转换为任意其它类型的空指针.
* `void*`指针, 它可以指向任何数据类型, 但是无法取对象, 因此取对象的时候我们需要进行强制转换

一般遇到类型复杂的时候, **我们采用从右向左读的方式进行类型解析**



### `const`限定符

`const`对象被创建之后它的值就不能被改变了, 所以它必须进行初始化

#### 默认情况下`const`对象仅在文件内有效

如果多个文件中都想使用`const`定义的变量, 我们必须在**每个使用到它的文件中都单独的进行定义**, 因此默认情况下**`const`被设定为仅在当前文件内有效**, 如果我们想要在多个文件中进行共享那么**不管定义还是声明我们都需要在它之前添加`extern`**

```c++
// file1.cpp中定义一个const常量
extern const int bufSize = fcn();

// file2.cpp中我们可以进行引用
extern const int bufSize;
```

#### `const`引用

可以把引用绑定到`const`对象上, 我们称之为**对`const`的引用**, 和普通引用所不同的是, 对常量的引用不能改变它所绑定的对象, 也就是这种引用表名**它所引用的对象都是常量, 包括基本类型**

#### 初始化和对`const`的引用

一般来说引用的类型必须要和所引用对象的类型保持一致, 但是存在两个例外:

1. 初始化常量引用的时候允许用任意表达式作为初始值, 只要该表达式的结果能转换成引用的类型即可. 尤其, 允许一个常量引用绑定非常量的对象, 字面值甚至一般表达式

   可是该如何理解这种行为呢? 实际上编译器做了优化

   ```c++
   double dval = 3.14;
   const int & ri = dval;
   // 上面是一个很正确的C++引用的赋值
   
   // 实际上编译器做了如下的优化
   const int temp = dval;
   const int &ri = temp;
   // 也就是在引用过程中产生了一个临时的整型常量, 也就是所说的临时量
   ```

   **临时量**就是引用表达式, 和类型不匹配时编译器的解决方法

2. 对`const`的引用可能并非引用一个`const`对象



#### 指针和`const`

这一点和`C`语言并没有什么不同, `const`在前表示指向的值无法改变, `const`在后表示指针无法被改变;

`const`指针意味着指向常量的指针, 因此可以用指向**常量**



### 顶层`const`

**顶层`const`**表示指针本身是一个常量, **底层`const`**表示指针所指的对象为一个常量, **因此, 我们可以通过判断变量本身是否可变来表示顶层和底层**(自己最大)







